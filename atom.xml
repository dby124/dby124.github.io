<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>beatrice&#39;s blogs</title>
  
  <subtitle>开启程序员之旅，坚持学习和思考，想知道最后的自己能做到哪一步，拭目以待吧。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T07:13:24.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>beatrice</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prototyping platform of LearningADD system</title>
    <link href="http://yoursite.com/2020/06/25/Prototyping-platform-of-LearningADD-system/"/>
    <id>http://yoursite.com/2020/06/25/Prototyping-platform-of-LearningADD-system/</id>
    <published>2020-06-24T16:15:38.000Z</published>
    <updated>2020-06-28T07:13:24.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Acoustic-detection"><a href="#Acoustic-detection" class="headerlink" title="Acoustic-detection"></a>Acoustic-detection</h1><p>Machine Learning based Acoustic Defect Detection in Factory Automation: Feature Extraction and Deployment Strategies</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>The detection of invisible cracks in empty glass bottles is an important process before the filling of liquor production. Light inspection is used to ensure the integrity of empty bottles before filling. However, in the actual production process, the compulsory light inspection by labor is long, high labor intensity, and large-employees, which increases Labor costs, management difficulties and other issues. Furthermore, with the liquor industry from the traditional manual work, manual tactics to mechanization, automation, information technology, intelligent production to march forward during the process, the detection of invisible cracks in empty bottles poses new challenges, such as fully automatic online detection and online automatic rejection, and therefore use machines instead of manual labor to reduce labor intensity, increase production efficiency and ensure product quality.</p><h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><p>This paper sets glass bottles as experiment objects. The data set is collected from a prototyping platform. Firstly, we set 2000 percussion signals generated from 1000 defective and 1000 defect-free bottles as experiment data. Then, we divide all data into the training set with 1200 signals and the test set with 800 signals. Among training set and testing set, the defective and defect-free bottles have equal sample number.</p><p>It is noted that there are two splitting method for dataset, which is respectively split randomly and by time.</p><h2 id="Prototyping-platform-of-LearningADD-system"><a href="#Prototyping-platform-of-LearningADD-system" class="headerlink" title="Prototyping platform of LearningADD system"></a>Prototyping platform of LearningADD system</h2><p>The prototyping platform of LearningADD system is introduced as following.</p><h3 id="1）System-block-diagram"><a href="#1）System-block-diagram" class="headerlink" title="1）System block diagram"></a>1）System block diagram</h3><p><strong>（1）System block diagram</strong>. The system mainly consists of Data Collection, Defect Detection, and Control Action. Here, the classifier is built after feature extraction. The decision output is used to control Defect Indicator and Rejection Equipment for defective bottle.</p><p><img src="/images/LearningADD_images/System_block_diagram.png" alt="System_block_diagram"></p><p><strong>（2）Prototyping system of LearningADD system</strong>.</p><p>Prototyping system of LearningADD system collects acoustic signals and control related equipment. Firstly, Object under Detection(glass bottles) is conveyed to Positioning Equipment by Conveyor Belt. Here, Positioning Equipment ensures the correct distance between the bottle and Knocking Equipment (metal rod). Secondly, the bottle is sent to Object Detector (pair tube photoelectric) for checking its passing. Finally, acoustic signal is collected by an Acoustic Collection Module after knocking a bottle body by Knocking Equipment.</p><p>After collecting the acoustic signal, the signal is transmitted to Field Controller including Industrial Personal Computer (IPC) and Digital Signal Processor dsk5416. Then, Defect Indicator will display the decision output. Finally, the defective bottles will be rejected by Rejection Equipment.</p><p><img src="/images/LearningADD_images/prototyping_platform.png" alt="prototyping_platform"></p><h3 id="2）Data-stream"><a href="#2）Data-stream" class="headerlink" title="2）Data stream"></a>2）Data stream</h3><p>The picture show that the data stream in device layer.</p><p><img src="/images/LearningADD_images/data_stream.png" alt="data_stream"></p><h3 id="3）Experimental-workshop"><a href="#3）Experimental-workshop" class="headerlink" title="3）Experimental workshop"></a>3）Experimental workshop</h3><p><img src="/images/LearningADD_images/workshop.png" alt="workshop"></p><h3 id="4）Experimental-subject"><a href="#4）Experimental-subject" class="headerlink" title="4）Experimental subject"></a>4）Experimental subject</h3><p><img src="/images/LearningADD_images/glass_bottle.png" alt="glass_bottle"><br><img src="/images/LearningADD_images/glass_bottles.png" alt="glass_bottles"></p><h3 id="5）Conveyor-belt"><a href="#5）Conveyor-belt" class="headerlink" title="5）Conveyor belt"></a>5）Conveyor belt</h3><p><img src="/images/LearningADD_images/Conveyor_belt.png" alt="Conveyor_belt"></p><h3 id="6）Positioning-equipment"><a href="#6）Positioning-equipment" class="headerlink" title="6）Positioning equipment"></a>6）Positioning equipment</h3><p><img src="/images/LearningADD_images/Positioning_equipment.jpg" alt="Positioning_equipment"></p><h3 id="7）Acoustic-collection-module"><a href="#7）Acoustic-collection-module" class="headerlink" title="7）Acoustic collection module"></a>7）Acoustic collection module</h3><p><img src="/images/LearningADD_images/Acoustic_collection2.jpg" alt="Acoustic_collection2"></p><p><img src="/images/LearningADD_images/Acoustic_collection.jpg" alt="Acoustic_collection"></p><h3 id="8）Field-Controller"><a href="#8）Field-Controller" class="headerlink" title="8）Field Controller"></a>8）Field Controller</h3><p>Field_controller:</p><p><img src="/images/LearningADD_images/Field_controller.jpg" alt="Field_controller"></p><p>dsk5416:<br><img src="/images/LearningADD_images/dsk5416.jpg" alt="dsk5416"></p><h3 id="9）Waveform-display"><a href="#9）Waveform-display" class="headerlink" title="9）Waveform display"></a>9）Waveform display</h3><p><img src="/images/LearningADD_images/waveform.jpg" alt="waveform"></p><p><img src="/images/LearningADD_images/waveform2.jpg" alt="waveform2"></p><h3 id="10）Defect-Indicator"><a href="#10）Defect-Indicator" class="headerlink" title="10）Defect Indicator"></a>10）Defect Indicator</h3><p><img src="/images/LearningADD_images/Defect_indicator.jpg" alt="Defect_indicator"></p><h3 id="11）Rejection-equipment"><a href="#11）Rejection-equipment" class="headerlink" title="11）Rejection equipment"></a>11）Rejection equipment</h3><p><img src="/images/LearningADD_images/rejection.jpg" alt="rejection"></p><h3 id="12）vedios"><a href="#12）vedios" class="headerlink" title="12）vedios"></a>12）vedios</h3><iframe width="800" height="400" src="/images/LearningADD_vedios/device1.mp4" frameborder="0" allowfullscreen><br></iframe><iframe width="800" height="600" src="/images/LearningADD_vedios/device2.mp4" frameborder="0" allowfullscreen><br></iframe><iframe width="800" height="450" src="/images/LearningADD_vedios/waveform_display.mp4" frameborder="0" allowfullscreen><br></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Acoustic-detection&quot;&gt;&lt;a href=&quot;#Acoustic-detection&quot; class=&quot;headerlink&quot; title=&quot;Acoustic-detection&quot;&gt;&lt;/a&gt;Acoustic-detection&lt;/h1&gt;&lt;p&gt;Machin
      
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="project" scheme="http://yoursite.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 的 Eloquent ORM学习</title>
    <link href="http://yoursite.com/2019/01/14/Laravel%20%E7%9A%84%20Eloquent%20ORM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/14/Laravel 的 Eloquent ORM学习/</id>
    <published>2019-01-14T12:22:38.000Z</published>
    <updated>2020-06-26T15:18:46.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>首先，创建一个 Eloquent 模型，生成的模型通常放在 app 目录中，但你可以通过 composer.json 随意地将它们放在可被自动加载的地方。所有的 Eloquent 模型都继承了 Illuminate\Database\Eloquent\Model 类。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">namespace DriverTaskEditor\Models\Dao;</div><div class="line"></div><div class="line">use DriverTaskEditor\Core\Dao;</div><div class="line">use DriverTaskEditor\Common\Constant;</div><div class="line"></div><div class="line">class ActivityDao extends Dao</div><div class="line">&#123;</div><div class="line">    /**</div><div class="line">     *（1）数据表名，必填  @var string</div><div class="line">     */</div><div class="line">    protected $table = &apos;activity&apos;;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     *（2）主键，可选  @var int</div><div class="line">     * Eloquent 也会假定每个数据表都有一个名为 id 的主键字段。你可以定义一个受保护的 $primaryKey 属性来覆盖这个约定。</div><div class="line">     * Eloquent 假定主键是一个递增的整数值，这意味着在默认情况下主键会自动转换为 int。 如果使用的是非递增或者非数字的主键，则必须在模型上设置 public $incrementing = false。如果主键不是一个整数，则应该在模型上设置 protected $keyType = string</div><div class="line">     */</div><div class="line">     </div><div class="line">    /**</div><div class="line">     *（3）要连接的数据库(database.php中的key),可选,默认&apos;default&apos;，@var string</div><div class="line">     */ </div><div class="line">    protected $connection = &apos;driver_task&apos;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * (4)必填:强转主键值类型; 使用toArray方法时,组件会根据主键自增类型,将主键类型转换为int; </div><div class="line">     * 故需要通过$casts再转回string，有些模型有这个变量有些没有，@var array</div><div class="line">     */</div><div class="line">    protected $casts = [</div><div class="line">        &apos;segments&apos;          =&gt; &apos;array&apos;,</div><div class="line">        &apos;segment_conditions&apos;=&gt; &apos;array&apos;,</div><div class="line">        &apos;cities&apos;            =&gt; &apos;array&apos;,</div><div class="line">        &apos;status&apos;            =&gt; &apos;int&apos;,</div><div class="line">        &apos;group_id&apos;          =&gt; &apos;int&apos;,</div><div class="line">        &apos;trigger_type&apos;      =&gt; &apos;int&apos;,</div><div class="line">        &apos;product_id&apos;        =&gt; &apos;int&apos;,</div><div class="line">        &apos;product_line&apos;      =&gt; &apos;array&apos;,</div><div class="line">        &apos;evaluate_info&apos;     =&gt; &apos;array&apos;,</div><div class="line">        &apos;task_ids&apos;          =&gt; &apos;array&apos;,</div><div class="line">        &apos;extra&apos;             =&gt; &apos;array&apos;,</div><div class="line">        &apos;render_info&apos;       =&gt; &apos;array&apos;,</div><div class="line">    ];</div><div class="line">    </div><div class="line"></div><div class="line">    /**</div><div class="line">     * (5)需要被转换成日期的属性。</div><div class="line">     *</div><div class="line">     * @var array</div><div class="line">     */</div><div class="line">    protected $dates = [</div><div class="line">        &apos;create_time&apos;,</div><div class="line">        &apos;modify_time&apos;,</div><div class="line">    ];</div><div class="line"></div><div class="line">    /**</div><div class="line">     * (6)列表中的字段不可被批量赋值(create方法创建时不会写入该字段)</div><div class="line">     * $guarded和$fillable 二选一，一个表示黑名单，一个表示白名单</div><div class="line">     * @var array</div><div class="line">     */</div><div class="line">    protected $guarded = [&apos;id&apos;];</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * (7)该模型是否被自动维护时间戳，可选，@var bool，默认为true</div><div class="line">     * Eloquent 会默认数据表中存在 created_at 和 updated_at这两个字段,如果你不需要这两个字段，则需要在模型内将 $timestamps 属性设置为 false</div><div class="line">     */</div><div class="line"></div><div class="line">    /**</div><div class="line">     * (8)如果需要自定义用于存储时间戳的字段名，可在模型中通过设置 CREATED_AT 和 UPDATED_AT 常量来实现：</div><div class="line">     * 更新时间和修改时间的字段，如果没有则设置public $timestamps = false;</div><div class="line">     */</div><div class="line">    const CREATED_AT = &apos;create_time&apos;;</div><div class="line">    const UPDATED_AT = &apos;modify_time&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="检索多个模型"><a href="#检索多个模型" class="headerlink" title="检索多个模型"></a>检索多个模型</h3><p>Eloquent 的 all 方法会返回模型表中所有的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">use App\Flight;</div><div class="line"></div><div class="line">$flights = App\Flight::all();</div><div class="line"></div><div class="line">foreach ($flights as $flight) &#123;</div><div class="line">    echo $flight-&gt;name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于每个 Eloquent 模型都可以当作一个 查询构造器，因此你还可以在查询中添加约束，然后使用 get 方法来获取结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$flights = App\Flight::where(&apos;active&apos;, 1)</div><div class="line">               -&gt;orderBy(&apos;name&apos;, &apos;desc&apos;)</div><div class="line">               -&gt;take(10)</div><div class="line">               -&gt;get();</div></pre></td></tr></table></figure><p>注意： Eloquent 模型是查询构造器，因此你应当去阅读 <a href="https://laravel-china.org/docs/laravel/5.5/queries/1327" target="_blank" rel="external">查询构造器</a> 提供的所有方法，以便你可以在 Eloquent 查询中使用。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>1、分块结果：如果需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Flight::chunk(200, function ($flights) &#123;</div><div class="line">    foreach ($flights as $flight) &#123;</div><div class="line">        //</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>注意：传递到方法的第一个参数是希望每个「分块」接收的数据量。闭包则被作为第二个参数传递，它会在每次执行数据库查询传递每个块时被调用。</p><p>2、使用游标：cursor 允许你使用游标来遍历数据库数据，该游标只执行一个查询。处理大量数据时，可以使用 cursor 方法可以大幅度减少内存的使用量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foreach (Flight::where(&apos;foo&apos;, &apos;bar&apos;)-&gt;cursor() as $flight) &#123;</div><div class="line">    //</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="检索单个模型／集合"><a href="#检索单个模型／集合" class="headerlink" title="检索单个模型／集合"></a>检索单个模型／集合</h3><p>除了从指定的数据表检索所有记录外，你也可以通过 find 或 first 方法来检索单条记录。这些方法不是返回一组模型，而是返回一个模型实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 通过主键取回一个模型...</div><div class="line">$flight = App\Flight::find(1);</div><div class="line"></div><div class="line">// 取回符合查询限制的第一个模型 ...</div><div class="line">$flight = App\Flight::where(&apos;active&apos;, 1)-&gt;first();</div></pre></td></tr></table></figure><p>你也可以用主键数组为参数调用 find 方法，它将返回匹配记录的集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$flights = App\Flight::find([1, 2, 3]);</div></pre></td></tr></table></figure><p>「找不到」异常<br>如果你希望在找不到模型时抛出异常，可以使用 findOrFail 以及 firstOrFail 方法。这些方法会检索查询的第一个结果。如果没有找到相应结果，就会抛出一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Illuminate\Database\Eloquent\ModelNotFoundException：</div><div class="line"></div><div class="line">$model = App\Flight::findOrFail(1);</div><div class="line"></div><div class="line">$model = App\Flight::where(&apos;legs&apos;, &apos;&gt;&apos;, 100)-&gt;firstOrFail();</div></pre></td></tr></table></figure></p><p>如果没有对异常进行捕获，则会自动返回 HTTP 404 响应给用户。也就是说，在使用这些方法时，不需要另外写个检查来返回 404 响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(&apos;/api/flights/&#123;id&#125;&apos;, function ($id) &#123;</div><div class="line">    return App\Flight::findOrFail($id);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>你还可以使用 查询构造器 提供的 count、sum、max 以及其它 聚合函数。这些方法只会返回适当的标量值而不是整个模型实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$count = App\Flight::where(&apos;active&apos;, 1)-&gt;count();</div><div class="line"></div><div class="line">$max = App\Flight::where(&apos;active&apos;, 1)-&gt;max(&apos;price&apos;);</div></pre></td></tr></table></figure><h2 id="插入和更新模型"><a href="#插入和更新模型" class="headerlink" title="插入和更新模型"></a>插入和更新模型</h2><p>1、save方法插入新数据。<br>要在数据库中创建新记录，只需创建一个新的模型实例，并在模型上设置属性，然后调用 save 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//插入</div><div class="line">$flight = new Flight; </div><div class="line">$flight-&gt;name = $request-&gt;name;</div><div class="line">$flight-&gt;save();</div><div class="line"></div><div class="line"></div><div class="line">$flight = App\Flight::create([&apos;name&apos; =&gt; &apos;Flight 10&apos;]);</div><div class="line"></div><div class="line">//如果你已经有一个模型实例，你可以传递数组给 fill 方法：</div><div class="line">$flight-&gt;fill([&apos;name&apos; =&gt; &apos;Flight 22&apos;]);</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * 其他创建方法</div><div class="line"> */</div><div class="line"></div><div class="line">// 通过 name 属性检索航班，当结果不存在时创建它...</div><div class="line">$flight = App\Flight::firstOrCreate([&apos;name&apos; =&gt; &apos;Flight 10&apos;]);</div><div class="line"></div><div class="line">// 通过 name 属性检索航班，当结果不存在的时候用 name 属性和 delayed 属性去创建它</div><div class="line">$flight = App\Flight::firstOrCreate(</div><div class="line">    [&apos;name&apos; =&gt; &apos;Flight 10&apos;], [&apos;delayed&apos; =&gt; 1]</div><div class="line">);</div><div class="line"></div><div class="line">// 通过 name 属性检索航班，当结果不存在时实例化...</div><div class="line">$flight = App\Flight::firstOrNew([&apos;name&apos; =&gt; &apos;Flight 10&apos;]);</div><div class="line"></div><div class="line">// 通过 name 属性检索航班，当结果不存在的时候用 name 属性和 delayed 属性实例化</div><div class="line">$flight = App\Flight::firstOrNew(</div><div class="line">    [&apos;name&apos; =&gt; &apos;Flight 10&apos;], [&apos;delayed&apos; =&gt; 1]</div><div class="line">);</div><div class="line"></div><div class="line">//updateOrCreate</div><div class="line">// 如果有从奥克兰飞往圣地亚哥的航班，将价格设为 99 美元</div><div class="line">// 如果不存在匹配的模型就创建一个</div><div class="line">$flight = App\Flight::updateOrCreate(</div><div class="line">    [&apos;departure&apos; =&gt; &apos;Oakland&apos;, &apos;destination&apos; =&gt; &apos;San Diego&apos;],</div><div class="line">    [&apos;price&apos; =&gt; 99]</div><div class="line">);</div></pre></td></tr></table></figure><p>2、更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//批量插入，update</div><div class="line">方法需要传入表示要更新的字段的字段的值的键值对数组。</div><div class="line">App\Flight::where(&apos;active&apos;, 1)</div><div class="line">          -&gt;where(&apos;destination&apos;, &apos;San Diego&apos;)</div><div class="line">          -&gt;update([&apos;delayed&apos; =&gt; 1]);</div></pre></td></tr></table></figure><p>3、删除</p><p>可以在模型实例上调用 delete 方法来删除模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//通过主键删除</div><div class="line">$flight = App\Flight::find(1);</div><div class="line">$flight-&gt;delete();</div><div class="line"></div><div class="line">//如果你已知道了这个模型的主键，则可以直接调用 destroy 方法删除它：</div><div class="line">App\Flight::destroy(1);</div><div class="line">App\Flight::destroy([1, 2, 3]);</div><div class="line">App\Flight::destroy(1, 2, 3);</div><div class="line"></div><div class="line">//通过查询删除模型</div><div class="line">$deletedRows = App\Flight::where(&apos;active&apos;, 0)-&gt;delete();</div><div class="line">//注意：使用 Eloquent 执行批量删除语句时，deleting 和 deleted 模型事件不会为已删除的模型触发。因为在执行删除语句时，不会检索模型实例。</div></pre></td></tr></table></figure></p><p>参考：<br><a href="https://laravel-china.org/docs/laravel/5.5/queries/1327" target="_blank" rel="external">Eloquent: 入门</a></p><p>转载请注明：本文档由 Laravel China 社区 laravel-china.org 组织翻译，详见 翻译召集帖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建模型&quot;&gt;&lt;a href=&quot;#创建模型&quot; class=&quot;headerlink&quot; title=&quot;创建模型&quot;&gt;&lt;/a&gt;创建模型&lt;/h2&gt;&lt;p&gt;首先，创建一个 Eloquent 模型，生成的模型通常放在 app 目录中，但你可以通过 composer.json 随意地
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel数据库相关操作</title>
    <link href="http://yoursite.com/2019/01/14/laravel%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/01/14/laravel数据库相关操作/</id>
    <published>2019-01-14T12:22:38.000Z</published>
    <updated>2020-06-26T15:19:09.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><p>配置好数据库连接后，可以使用 DB facade 运行查询。DB facade 为每种类型的查询提供了方法：select、update、insert、delete 和 statement。</p><h3 id="select查询数据"><a href="#select查询数据" class="headerlink" title="select查询数据"></a>select查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use Illuminate\Support\Facades\DB;</div><div class="line"></div><div class="line">//select方法一</div><div class="line">$users = DB::select(&apos;select * from users where active = ?&apos;, [1]);</div><div class="line"></div><div class="line">//(1)传递到 select 方法的第一个参数是一个原生的 SQL 查询，而第二个参数则是传递需要绑定到查询中的参数值。通常，这些是 where 子句约束的值。参数绑定提供了对防止 SQL 注入的保护。</div><div class="line">//(2)select 方法将始终返回一个数组。数组中的每个结果都是一个PHP StdClass 对象，可以像下面这样访问结果的值:</div><div class="line"></div><div class="line">foreach ($users as $user) &#123;</div><div class="line">    echo $user-&gt;name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//select方法二</div><div class="line">$results = DB::select(&apos;select * from users where id = :id&apos;, [&apos;id&apos; =&gt; 1]);</div></pre></td></tr></table></figure><h3 id="增删改方法"><a href="#增删改方法" class="headerlink" title="增删改方法"></a>增删改方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use Illuminate\Support\Facades\DB;</div><div class="line"></div><div class="line">//可以在 DB facade 上使用 insert 方法来执行 insert 语句。与 select 一样</div><div class="line">//该方法将原生 SQL 查询作为其第一个参数，并将其绑定的数据作为第二个参数：</div><div class="line">DB::insert(&apos;insert into users (id, name) values (?, ?)&apos;, [1, &apos;Dayle&apos;]);</div><div class="line"></div><div class="line">//update 方法用于更新数据库中的现有记录。该方法会返回受该语句影响的行数：</div><div class="line">$affected = DB::update(&apos;update users set votes = 100 where name = ?&apos;, [&apos;John&apos;]);</div><div class="line"></div><div class="line"></div><div class="line">//delete 方法用于删除数据库中记录。与 update 一样，会返回受该语句影响的行数：</div><div class="line">$deleted = DB::delete(&apos;delete from users&apos;);</div></pre></td></tr></table></figure><h2 id="laravel数据库事务"><a href="#laravel数据库事务" class="headerlink" title="laravel数据库事务"></a>laravel数据库事务</h2><p>可以在 DB facade 上使用 transaction 方法来运行数据库事务中的一组操作。如果在事务 Closure 中发生了异常，事务将自动回滚。而如果 Closure 成功执行，事务将自动被提交。也就是说，使用数据库事务，你就不需要在数据库语句执行发生异常时手动回滚或提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// (1)如果在事务 Closure 中发生了异常，事务将自动回滚，否则事务自动提交</div><div class="line">DB::transaction(function () &#123;</div><div class="line">    DB::table(&apos;users&apos;)-&gt;update([&apos;votes&apos; =&gt; 1]);</div><div class="line"></div><div class="line">    DB::table(&apos;posts&apos;)-&gt;delete();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// (2)处理死锁，第二个参数定义在发生死锁时应该重新尝试事务的次数。一旦尝试次数都用尽了，就会抛出一个异常：</div><div class="line">DB::transaction(function () &#123;</div><div class="line">    DB::table(&apos;users&apos;)-&gt;update([&apos;votes&apos; =&gt; 1]);</div><div class="line"></div><div class="line">    DB::table(&apos;posts&apos;)-&gt;delete();</div><div class="line">&#125;, 5);</div><div class="line"></div><div class="line">// (3)手动开始一个事务，并且能够完全控制回滚和提交</div><div class="line">DB::beginTransaction();</div><div class="line"></div><div class="line">//可以通过 rollBack 方法回滚事务：</div><div class="line">DB::rollBack();</div><div class="line"></div><div class="line">//最后记得要通过 commit 方法提交事务：</div><div class="line">DB::commit();</div></pre></td></tr></table></figure><p>注意：DB facade 的事务方法也适用于 查询语句构造器 和 Eloquent ORM 的事务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL查询&quot;&gt;&lt;a href=&quot;#SQL查询&quot; class=&quot;headerlink&quot; title=&quot;SQL查询&quot;&gt;&lt;/a&gt;SQL查询&lt;/h2&gt;&lt;p&gt;配置好数据库连接后，可以使用 DB facade 运行查询。DB facade 为每种类型的查询提供了方法：sele
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>vim的模式及常用命令</title>
    <link href="http://yoursite.com/2018/11/24/vim%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/11/24/vim的模式及常用命令/</id>
    <published>2018-11-24T12:59:38.000Z</published>
    <updated>2019-03-14T03:43:54.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><ul><li><p><strong>正常模式</strong> (Normal-mode) ： 左下角显示文件名或为空。</p><p>  启动vim后默认处于正常模式。不论位于什么模式，<strong>按下<code>&lt;Esc&gt;</code>键</strong>(有时需要按两下）都会进入正常模式。</p></li><li><p><strong>插入模式</strong> (Insert-mode)：左下角显示–INSERT–</p><p>  在正常模式中<strong>按下i, I, a, A等键</strong>，会进入插入模式。现在只用记住按i键会进行插入模式。在插入模式中，击键时会写入相应的字符。</p></li><li><p><strong>命令模式</strong> (Command-mode)：左下角显示:</p><p>  在正常模式中，<strong>按下:（英文冒号）键</strong>，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p><p>  常用的命令有：q（退出）、q!（强制退出）、w（保存）、wq（保存并退出）</p></li><li><p><strong>可视模式</strong> (Visual-mode)：左下角显示–VISUAL–</p><p>  在正常模式中<strong>按下v, V, <code>&lt;Ctrl&gt;+v</code></strong>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</p></li></ul><h2 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h2><ul><li><p>启动vim，在命令行窗口中输入以下命令即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim     // 直接启动vim</div><div class="line"></div><div class="line">vim filename    // 打开vim并创建名为filename的文件</div></pre></td></tr></table></figure></li><li><p>退出vim命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">:w      保存文件但不退出vi</div><div class="line">:w file 将修改另外保存到file中，不退出vi</div><div class="line">:w!     强制保存，不推出vi</div><div class="line">:wq     保存文件并退出vi</div><div class="line">:wq!    强制保存文件，并退出vi</div><div class="line">:q      不保存文件，退出vi</div><div class="line">:q!     不保存文件，强制退出vi</div><div class="line">:e!     放弃所有修改，从上次保存文件开始再编辑命令历史</div></pre></td></tr></table></figure><blockquote><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令</p></blockquote></li><li><p>撤销和重做</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">u       撤销（Undo）</div><div class="line">U       撤销对整行的操作</div><div class="line">Ctrl + r 重做（Redo），即撤销的撤销。</div></pre></td></tr></table></figure></li><li><p>删除命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">x   删除当前字符</div><div class="line">3x  删除当前光标开始向后三个字符</div><div class="line">X   删除当前字符的前一个字符。X=dh</div><div class="line">dl  删除当前字符， dl=x</div><div class="line">dh  删除前一个字符</div><div class="line">dd  删除当前行</div><div class="line">dj  删除上一行</div><div class="line">dk  删除下一行</div><div class="line">10d 删除当前行开始的10行。</div><div class="line">D   删除当前字符至行尾。D=d$</div><div class="line">d$  删除当前字符之后的所有字符（本行）</div><div class="line">kdgg 删除当前行之前所有行（不包括当前行）</div><div class="line">jdG（jd shift + g） 删除当前行之后所有行（不包括当前行）</div><div class="line">:1,10d  删除1-10行</div><div class="line">:11,$d  删除11行及以后所有的行</div><div class="line">:1,$d   删除所有行</div><div class="line">J(shift + j)　　删除两行之间的空行，实际上是合并两行。</div></pre></td></tr></table></figure></li></ul><h2 id="移动光标位置"><a href="#移动光标位置" class="headerlink" title="移动光标位置"></a>移动光标位置</h2><p>在正常模式下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">hjkl 左下上右    </div><div class="line">shift+4($):末尾    g+_:末尾   </div><div class="line">shift+6(^):开头    0:开头 </div><div class="line"></div><div class="line">w:下一个单词(仅包含字母)    W:下一个单词(包含特殊符号)     </div><div class="line">b:上一个单词                B:上一个单词  </div><div class="line">e:下一个单词末尾            E:下一个单词末尾</div><div class="line"></div><div class="line">ctrl+f:上一页</div><div class="line">ctrl+b:下一页</div><div class="line">ctrl+d:上半页</div><div class="line">ctrl+u:下半页</div><div class="line">ctrl+e:下一行（光标不动，显示页面下移一行）</div><div class="line">ctrl+y:上一行（光标不动，显示页面上移一行）</div><div class="line"></div><div class="line">G:文末    </div><div class="line">gg:文头    </div><div class="line">nG:跳到第n行     </div><div class="line">H:跳到当前页的第1行  </div><div class="line">M:跳到当前页的中间那行</div></pre></td></tr></table></figure><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dd:删除一行  </div><div class="line">p:粘贴    </div><div class="line">yy:拷贝一行   </div><div class="line">ndd/nyy:删除/复制第n行</div></pre></td></tr></table></figure><h2 id="查找-替换"><a href="#查找-替换" class="headerlink" title="查找,替换"></a>查找,替换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/pattern    前向查找    </div><div class="line">?pattern    后向查找     </div><div class="line">n:          next      </div><div class="line">shift+n:    反向的next</div><div class="line">s/pattern1/pattern2:        替换       </div><div class="line">s/pattern1/pattern2/g:      替换当前行所有</div><div class="line">1,$s/pattern1/pattern2/g:   替换从第一行开始所有</div></pre></td></tr></table></figure><h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctrl+v:开始选择要操作的块</div><div class="line">I 然后   ＃插入多行注释</div><div class="line">d:删除   s:删除后替换</div></pre></td></tr></table></figure><h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//分屏后可直接采用:q命令退出当前窗口</div><div class="line">split:上下分屏    vsplit:左右分屏</div><div class="line">ctrl+w+hjkl:切换分屏到不同方向</div><div class="line">e:打开文件</div></pre></td></tr></table></figure><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><ul><li><p>打开单个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim file</div></pre></td></tr></table></figure></li><li><p>同时打开多个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim file1 file2 file3 ...</div></pre></td></tr></table></figure></li><li><p>删除文件或删除目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm file     删除文件</div><div class="line">rm -rf dir  删除目录</div></pre></td></tr></table></figure></li><li><p>在vim窗口中打开一个新文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:open file</div></pre></td></tr></table></figure></li><li><p>在新窗口中打开文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:split file</div></pre></td></tr></table></figure></li><li><p>切换到下一个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:bn</div></pre></td></tr></table></figure></li><li><p>切换到上一个文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:bp</div></pre></td></tr></table></figure></li></ul><ul><li><p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:args</div></pre></td></tr></table></figure></li><li><p>打开远程文件，比如ftp或者share folder</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:e ftp://192.168.10.76/abc.txt</div><div class="line"></div><div class="line">:e \qadrive\test\1.txt</div></pre></td></tr></table></figure></li></ul><p>参考：</p><ol><li><a href="https://www.jianshu.com/p/0009bf462f15" target="_blank" rel="external">VIM中的保存和退出、VIM退出命令、如何退出vim编辑、VIM命令大全</a></li><li><a href="https://linuxtoy.org/archives/efficient-editing-with-vim.html" target="_blank" rel="external">高效率编辑器 Vim——操作篇，非常适合 Vim 新手</a></li><li><a href="https://blog.csdn.net/csyanbin/article/details/50879958" target="_blank" rel="external">terminal快捷键以及vim快捷键</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim的模式&quot;&gt;&lt;a href=&quot;#vim的模式&quot; class=&quot;headerlink&quot; title=&quot;vim的模式&quot;&gt;&lt;/a&gt;vim的模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;正常模式&lt;/strong&gt; (Normal-mode) ： 左下角显示文件
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>php 终止程序的方法——return、exit()、die()</title>
    <link href="http://yoursite.com/2018/10/26/php%20%E7%BB%88%E6%AD%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94return%E3%80%81exit()%E3%80%81die()/"/>
    <id>http://yoursite.com/2018/10/26/php 终止程序的方法——return、exit()、die()/</id>
    <published>2018-10-26T12:22:38.000Z</published>
    <updated>2020-06-26T15:16:39.920Z</updated>
    
    <content type="html"><![CDATA[<p><strong>php中终止程序的运行有三种方式</strong>：</p><ul><li>return，主脚本程序中使用</li><li>exit()，脚本中使用</li><li>die()， 脚本中使用</li></ul><blockquote><p>三者所在的脚本文件他们之后的代码都不会执行了。php开发模式下想直接看到变量的值使用exit()、die()。</p></blockquote><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>return是语言结构而不是函数。</p><p>如果一个函数中包含return 语句，当调用此函数时，函数的执行只会进行到return这一步，return之后的语句都不会执行，并将return的参数作为函数的值返回。</p><p>如果在全局范围中调用，则当前脚本文件中止运行。如果当前脚本文件是被 include 的或者 require 的，则控制交回调用文件。此外，如果当前脚本是被 include 的，则 return 的值会被当作 include 调用的返回值，相应的在主脚本文件中定义一个变量进行返回值的接收。</p><p>如果在主脚本文件中调用 return，则脚本中止运行。</p><p>注意事项：</p><ul><li><strong>返回参数，建议不加括号</strong>。因为return 是语言结构而不是函数，通常其参数都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。</li><li><strong>无参数返回时，一定不加括号</strong>。因为无参数返回时，默认返回 NULL。如果调用 return 时加上了括号却又没有参数会导致<strong>解析错误</strong>。</li></ul><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>输出一个消息并且退出当前脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void exit ([ string $status ] )</div><div class="line">void exit ( int $status )</div></pre></td></tr></table></figure></p><p>如果 status 是一个字符串，在退出之前该函数会打印 status 。</p><p>如果 status 是一个 integer，该值会作为退出状态码，并且不会被打印输出。 退出状态码应该在范围0至254，不应使用被PHP保留的退出状态码255。 状态码0用于成功中止程序。</p><p>Note: PHP &gt;= 4.2.0 当 status 是一个 integer，不会打印输出。</p><h3 id="die"><a href="#die" class="headerlink" title="die()"></a>die()</h3><p>关于die()的使用，官方文档给的是结构与die()一致。</p><p>说明：die()和exit()都是中止脚本执行函数；其实exit和die这两个名字指向的是同一个函数，die()是exit()函数的别名。该函数只接受一个参数，可以是一个程序返回的数值或是一个字符串，也可以不输入参数，结果没有返回值。</p><p>参考：虽然两者相同，但通常使用中也有细微的选择性。例如：</p><p>当传递给exit和die函数的值为0时，意味着提前终止脚本的执行，通常用exit()这个名字。</p><p>当程序出错时，可以给它传递一个字符串，它会原样输出在系统终端上，通常使用die()这个名字。</p><p>4、三者比较</p><p>功能上，die() 就等同于 exit();</p><p>PHP有多种运行方式，即可网站形式，也可脚本形式(不需要Web服务器)。</p><ul><li>当PHP为脚本形式运行时，建议用exit()：</li><li>当PHP为网站形式运行时，建议用die()：</li></ul><p>（1）die与exit<br>手册上标明 “die — Equivalent to exit().This language construct is equivalent to exit().”。<br>但在实际代码过程中可以存在一定的选择差别，例如这样：涉及到提前终止程序/脚本执行的情况，使用exit()；当程序出错，为了停止执行并显示提示信息时，使用die()。<br>（2）return与exit(或die)<br>return是结束当前的函数/文件/脚本/其他的执行，并将信息返回给调用他的其他 函数/文件/脚本/其他 。也就是说，执行到return后，程序并未完全结束，只是携带了有效的信息返回到调用他的上一级（这句话不严谨，如果return是在主脚本文件中，则该脚本也会停止执行），如果return有参数，还需要有变量接收返回值。 但是exit(或die)则不同，他是使当前执行停止到这里，并且不再进行下去。如果有参数，会直接打印出来（只针对字符串）。</p><p>参考：</p><ol><li><a href="https://blog.csdn.net/ydm19891101/article/details/72568704" target="_blank" rel="external">php 中return、exit()、die()用法比较</a></li><li><a href="http://www.phpernote.com/php-function/1064.html" target="_blank" rel="external">PHP中exit()与die()的区别</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;php中终止程序的运行有三种方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return，主脚本程序中使用&lt;/li&gt;
&lt;li&gt;exit()，脚本中使用&lt;/li&gt;
&lt;li&gt;die()， 脚本中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;三者
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Go简单开始</title>
    <link href="http://yoursite.com/2018/10/25/Go%E7%AE%80%E5%8D%95%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/10/25/Go简单开始/</id>
    <published>2018-10-25T05:18:38.000Z</published>
    <updated>2020-06-26T15:14:29.443Z</updated>
    
    <content type="html"><![CDATA[<p>Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令2。Go语<br>言提供的工具都通过一个单独的命令 go 调用， go 命令有一系列子命令。最简单的一个子命<br>令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可<br>执行文件。</p><p>执行go文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go run file_name.go</div></pre></td></tr></table></figure><p>如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以<br>用build子命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build helloworld.go</div></pre></td></tr></table></figure><blockquote><p>这个命令生成一个名为helloworld的可执行的二进制文件3，之后你可以随时运行它4，不需任<br>何处理。</p></blockquote><p>可以从gopl.io网站上本书源码仓库<br>里获取代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get gopl.io/ch1/helloworld</div></pre></td></tr></table></figure><p>在当前目录下得到bin和src文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">&quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">name := &quot;eatrice&quot;</div><div class="line">go func()&#123;</div><div class="line">fmt.Printf(&quot;hello, %s.\n&quot;, name)</div><div class="line">&#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述语句的输出结果本来应该是hello eatrice，但是执行结果却没有任何显示。这充分显示了Go语句的并发性，Go函数执行与其他的语句是并发，由于Go包装过程需要时间，所以，在main函数完成之前，Go语句还没来得及执行，就已经退出main函数了，因此执行没有结果。</p><p>通过对比下列的代码，我们可知，可采用runtime.Gosched()方式来保证Go语句的运行，。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">&quot;fmt&quot;</div><div class="line">&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">name := &quot;eatrice&quot;</div><div class="line">go func()&#123;</div><div class="line">fmt.Printf(&quot;hello, %s.\n&quot;, name)</div><div class="line">&#125;()</div><div class="line">runtime.Gosched()</div><div class="line">name = &quot;harry&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出是hello eatrice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">&quot;fmt&quot;</div><div class="line">&quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">name := &quot;eatrice&quot;</div><div class="line">go func()&#123;</div><div class="line">fmt.Printf(&quot;hello, %s.\n&quot;, name)</div><div class="line">&#125;()</div><div class="line">name = &quot;harry&quot;</div><div class="line">runtime.Gosched()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出是：hello harry</p><p>参考：<br>Go语言圣经<br>Go并发编程实战</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令2。Go语&lt;br&gt;言提供的工具都通过一个单独的命令 go 调用， go 命令有一系列子命令。最简单的一个子命&lt;br&gt;令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言</title>
    <link href="http://yoursite.com/2018/10/25/Go%20%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2018/10/25/Go 语言/</id>
    <published>2018-10-25T05:18:38.000Z</published>
    <updated>2020-06-26T15:14:39.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>Go 语言特色</strong></p><ul><li>简洁、快速、安全</li><li>并行、有趣、开源</li><li>内存管理、数组安全、编译迅速</li></ul></li><li><p><strong>应用</strong></p><p>  Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p><p>  对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p></li><li><p><strong>Go 语言最主要的特性</strong></p><ul><li>自动垃圾回收</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul></li></ul><h2 id="mac-os安装与环境配置"><a href="#mac-os安装与环境配置" class="headerlink" title="mac os安装与环境配置"></a>mac os安装与环境配置</h2><p><a href="https://golang.org/dl/" target="_blank" rel="external">安装包下载地址为</a></p><p>安装步骤：</p><ol><li><p>首先下载安装包（go1.11.darwin-amd64.pkg）。</p></li><li><p>双击已下载的安装包，按照提示安装Go。</p><p> 在Mac上的安装路径是：/usr/local/go<br>。</p><blockquote><p>可以通过<code>Contrl+shift+G</code>输入<code>/usr/local/go</code>进入这个路径。</p></blockquote></li></ol><ol><li><p>将安装目录加入到环境变量，命令如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=$PATH:/usr/local/go/bin</div></pre></td></tr></table></figure></li></ol><p>通过上面的步骤就完成了Go的安装。Go语言常用的编辑器是Goland。</p><p><strong>环境配置</strong></p><p>完成安装后，接下来是配置mac下的环境变量。这是最关键的。环境配置步骤如下：</p><ol><li><p>打开终端（Terminal），敲入一下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd ~    #进入当前用户下的根目录</div><div class="line"></div><div class="line">ls -a    # -a可将隐藏文件显示，可能会看到.bash_profile文件，若没有就自己创建</div><div class="line"></div><div class="line">vim .bash_profile   #创建很简单</div></pre></td></tr></table></figure></li><li><p>进入vim后，按下a才能编辑，输入一下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">export GOROOT=/usr/local/go</div><div class="line"></div><div class="line">export PATH=/usr/local/go/bin:$PATH</div><div class="line"></div><div class="line">export GOPATH=go代码默认存放路径</div></pre></td></tr></table></figure><p> 解释一下含义：</p><p> GOROOT就是pkg包默认安装到的地方，从官网上也可以看到，Go的pkg默认安装路径是/usr/local/go</p><p> PATH很重要，系统自带的源码要运行必须有这个路径，默认安装路径时，在/usr/local/go/bin</p><p> GOPATH可以是用户任意喜欢的地方，放置自己写的go程序</p><blockquote><p>此时，.bash_profile文件编写完毕，按esc，敲入:wq，回车，搞定。</p></blockquote></li><li><p>退回到终端后，敲入source  .bash_profile 使编辑生效</p><p> 验证一下路径配置是否成功：echo  $GOROOT ，就能看到/usr/local/go了。</p><p> 如果没有看到，再重启一下ternimal吧。</p></li><li><p>环境变量配置完成。</p></li></ol><h2 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h2><ul><li><p>Go 语言的基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul></li><li><p>编写有一个简单的go程序：main.go。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">   /* 这是我的第一个简单的程序 */</div><div class="line">   fmt.Println(&quot;Hello, World!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在terminal下列输入命令，运行上述的代码。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go run main.go</div><div class="line">// 输出：Hello, World!</div></pre></td></tr></table></figure></li></ul><p>程序解析：</p><ol><li><p>第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p></li><li><p>下一行 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素）。通过 import 关键字来导入其他非 main 包。</p><p> 可以通过 import 关键字单个导入:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &quot;fmt&quot;</div><div class="line">import &quot;io&quot;</div></pre></td></tr></table></figure><p> 也可以同时导入多个:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">    &quot;fmt&quot;,</div><div class="line">    &quot;io&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 使用 <packagename>.<functionname> 调用:</functionname></packagename></p><p> package 别名：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 为fmt起别名为fmt2</div><div class="line">import fmt2 &quot;fmt&quot;</div></pre></td></tr></table></figure><p> 省略调用(不建议使用):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 调用的时候只需要Println()，而不需要fmt.Println()</div><div class="line">import . &quot;fmt&quot;</div></pre></td></tr></table></figure><p> 前面加个点表示省略调用，那么调用该模块里面的函数，可以不用写模块名称了:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import . &quot;fmt&quot;</div><div class="line">func main ()&#123;</div><div class="line">    Println(&quot;hello,world&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>下一行 func main() 是程序开始执行的函数。Go 程序是通过 package 来组织的。<br>只有 package 名称为 main 的包可以包含 main 函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。<strong>一个可执行程序有且仅有一个 main 包</strong>。</p></li><li><p>注释，在程序执行时将被忽略。主要分为单行注释和多行注释。其中多行注释也叫块注释，不可以嵌套使用，一般用于包的文档描述或注释成块的代码片段。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 单行注释</div><div class="line">/*</div><div class="line"> Author by 菜鸟教程</div><div class="line"> 我是多行注释</div><div class="line"> */</div></pre></td></tr></table></figure></li><li><p>下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。fmt 包是实现了格式化 IO（输入/输出）的函数。<br>使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</p></li><li><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以开头字母的大小写来决定其是否能被外部包调用，具体如下：。</p><p> 函数名首字母小写即为 private ／protected（此部分的内容有待商榷，发现网上的一些资料是不一致的）:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func getId() &#123;&#125;</div></pre></td></tr></table></figure></li></ol><pre><code>函数名首字母大写即为 public :<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func Printf() &#123;&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="编辑器——Goland"><a href="#编辑器——Goland" class="headerlink" title="编辑器——Goland"></a>编辑器——Goland</h2><p>Go常用的一个编辑器是Goland</p><h2 id="Go框架-——Gin"><a href="#Go框架-——Gin" class="headerlink" title="Go框架 ——Gin"></a>Go框架 ——Gin</h2><p>Gin是一个<a href="https://www.jianshu.com/p/a31e4ee25305" target="_blank" rel="external">Golang 微框架</a>，封装比较优雅，API友好，源码注释比较明确，已经发布了1.0版本。具有快速灵活，容错方便等特点。其实对于golang而言，web框架的依赖要远比Python，Java之类的要小。</p><p>参考：</p><ol><li><p>参考：</p></li><li><p><a href="http://www.runoob.com/go/go-tutorial.html" target="_blank" rel="external">Go 语言教程</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Go 语言特色&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁、快速、安全&lt;/li&gt;
&lt;li&gt;并行、有趣
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PHP执行外部程序的方法</title>
    <link href="http://yoursite.com/2018/09/01/PHP%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/01/PHP执行外部程序的方法/</id>
    <published>2018-09-01T05:18:38.000Z</published>
    <updated>2020-06-26T15:08:56.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在一些特殊情况下，会使用PHP调用外部程序执行，比如：调用shell命令、shell脚本、可执行程序等等</p><p>PHP执行外部程序的方法</p><ul><li>system()，system函数将执行的结果直接输出</li><li>exec()：执行一个外部程序，将输出结果保存在第二个参数上</li><li>passthru()：执行外部程序并且显示原始输出</li><li>shell_exec()，没有参数中接收返回值，而且没有执行成功的状态码</li><li>proc_open()，会fork一个子进程，返回文件指针，但可提供双向通道</li><li>escapeshellcmd()：只是辅助作用</li><li>escapeshellarg()：只是辅助作用</li></ul><p>这些函数的使用前提：</p><ul><li>PHP没有运行在安全模式，关掉安全模式，即：<code>safe_mode = off</code></li><li>禁用函数列表 <code>disable_functions =  exec</code>, <code>system, shell_exec</code>,<code>proc_open</code>, <code>popen</code>, 如果禁用了，就关掉。<blockquote><p>注意：执行外部程序是存在风险的，所以使用这些函数要在确保安全的情况下使用。</p></blockquote></li></ul><p>exec() - 执行一个外部程序<br>passthru() - 执行外部程序并且显示原始输出<br>popen() - 打开进程文件指针，fork一个子进程，返回文件指针<br>escapeshellcmd() - shell 元字符转义<br>pcntl_exec() - 在当前进程空间执行指定程序</p><p>参考：</p><ol><li><a href="https://segmentfault.com/a/1190000008941850" target="_blank" rel="external">PHP执行外部程序的方法</a></li><li><a href="https://www.douban.com/note/211492486/" target="_blank" rel="external">PHP在linux上执行外部命令（整理）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在一些特殊情况下，会使用PHP调用外部程序执行，比如：调用shell命令、shell脚本、可执行程序等等&lt;/p&gt;
&lt;p&gt;PHP执行外部程序的
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>热部署与热加载</title>
    <link href="http://yoursite.com/2018/08/22/%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/08/22/热部署和热加载/</id>
    <published>2018-08-22T05:18:38.000Z</published>
    <updated>2020-06-26T15:05:08.461Z</updated>
    
    <content type="html"><![CDATA[<p>2018-8-22<br>今天入职第二天，看到老大在群里发了一个<a href="https://www.jb51.net/article/138627.htm" target="_blank" rel="external">go热加载实现</a>的链接，之前没有听说过热加载，所以搜索了一下，下面是关于热部署和热加载的相关整理。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在项目线上更新时，可能会遇到需要热部署的情况，虽然现在大多数公司由于业务量大采用了分布式集群，可以分批次的重启更新。但是还是有需要热部署</p><p>热部署和热加载的区别</p><table><thead><tr><th>比较</th><th>热部署</th><th>热加载</th></tr></thead><tbody><tr><td>部署方式</td><td>热部署在服务器运行时重新部署项目</td><td>热加载在运行时重新加载class</td></tr><tr><td>实现原理</td><td>热部署直接重新加载整个应用</td><td>热加载在运行时重新加载class</td></tr><tr><td>使用场景</td><td>热部署更多的是在生产环境使用</td><td>热加载则更多的实在开发环境使用(节省开发的时间和调试的时间)</td></tr><tr><td>安全性</td><td></td><td>热加载几乎没有</td></tr><tr><td>操作前后变化</td><td>会清空session ，释放内存</td><td>不清空session ，不释放内存。要考虑内存溢出的情况</td></tr></tbody></table><blockquote><p>热加载：依赖类的加载机制，在容器启动的时候后台会启动一个线程，定时间的检测类时间戳的变化，如果累的时间戳发生了变化，就将类重新带入，侧重的是运行时通过重新加载改变类的信息，直接改变程序的行为。</p></blockquote><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>就是已经运行了项目，更改之后，不需要重新tomcat，但是会清空内存,重新打包,重新解压war包运行</p><p>可能好处是一个tomcat多个项目,不必因为tomcat停止而停止其他的项目</p><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><p>是基于字节码进行更改的，不释放内存，开发可用，上线不可用，比如修改类了，原先的类内存不会释放，新的类还会增加内存。</p><p>更改字节码的意思是应该更改exploded war包中的.class文件.</p><p>热加载不重启tomcat，不重新打包</p><h2 id="更新静态资源"><a href="#更新静态资源" class="headerlink" title="更新静态资源"></a>更新静态资源</h2><p>更新静态资源是更改exploded war的静态资源，和热加载归到一起。</p><p>参考</p><ol><li><a href="https://blog.csdn.net/u010002783/article/details/62929314" target="_blank" rel="external">热部署和热加载</a></li><li><a href="https://www.cnblogs.com/ptqueen/p/8384898.html" target="_blank" rel="external">热部署和热加载的区别</a></li><li><a href="https://blog.csdn.net/Rundy_Deng/article/details/80262298" target="_blank" rel="external">热部署与热加载的配置</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-8-22&lt;br&gt;今天入职第二天，看到老大在群里发了一个&lt;a href=&quot;https://www.jb51.net/article/138627.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go热加载实现&lt;/a&gt;的链接，之前没有听说过热加
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP开发API</title>
    <link href="http://yoursite.com/2018/08/22/PHP%E5%BC%80%E5%8F%91API/"/>
    <id>http://yoursite.com/2018/08/22/PHP开发API/</id>
    <published>2018-08-22T05:18:38.000Z</published>
    <updated>2020-06-26T15:15:11.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如何使用 PHP 开发 API（Application Programming Interface，应用程序编程接口） 呢？</p><p>做过 API 的人应该了解，其实开发 API 比开发 WEB 更简洁，但可能逻辑更复杂，因为 API 其实就是数据输出，不用呈现页面，所以也就不存在 MVC（API 只有 M 和 C）。</p><ol><li>和 WEB 开发一样，首先需要一些相关的参数，这些参数，都会由客户端传过来，也许是 GET 也许是 POST，这个需要开发团队相互之间约定好，或者制定统一规范。</li><li>有了参数，根据应用需求，完成数据处理，例如：任务进度更新、APP内购、一局游戏结束数据提交等等</li><li>数据逻辑处理完之后，返回客户端所需要用到的相关数据，例如：任务状态、内购结果、玩家信息等等<br>数据怎么返给客户端？<br>直接输出的形式，如：JSON、XML、TEXT 等等。</li><li>客户端获取到你返回的数据后，在客户端本地和用户进行交互</li></ol><h2 id="API接口验证"><a href="#API接口验证" class="headerlink" title="API接口验证"></a><a href="https://blog.csdn.net/fmyzc/article/details/78798684" target="_blank" rel="external">API接口验证</a></h2><p>PHP写好接口后，前台就可以通过链接获取接口提供的数据，而返回的数据一般分为两种情况，xml和json。</p><p>在这个过程中，服务器并不知道，请求的来源是什么，有可能是别人非法调用我们的接口，获取数据，因此就要使用安全验证。</p><h2 id="API开发注意事项"><a href="#API开发注意事项" class="headerlink" title="API开发注意事项"></a>API开发注意事项</h2><p>实际项目中，我们在开发 API 应该注意的几个事项（仅供参考）：</p><ol><li><p>单文件实现多接口的形式有很多种，例如：if..elseif.. 或 switch 或 动态方法 (也就是TP的这种访问函数体的形式)</p></li><li><p>对于数据的输出最好用json，json具有相当强大的跨平台性，市场上各大主流编程语言都支持json解析，json正在逐步取代xml，成为网络数据的通用格式</p></li><li><p>接口安全，一定要增加接口验证。例如，客户端和服务端针对不同接口统一做好加密方式，服务端在对于每次接口需要都要进行验证。以保证防止接口被恶意刷新或黑客恶意调用，尤其是大型商业应用。</p></li><li><p>对于线上的 API 必须保证所有接口正常且关闭所有的错误信息 =&gt; error_reporting(0)，在输出JSON 时，不能有任何其它输出，否则，客户端将解析数据失败，直接 Crash！</p></li><li><p>开发 API 和 WEB 有一定的区别，如果是 WEB 的话，可能代码出错了，不会导致特别严重的错误，也许只是导致数据写入和查询失败，也许导致 WEB 的某个部分错位或乱码。但如果是 API，直接 Crash！</p></li><li><p>做接口开发，不建议使用框架开发，原因概括起来有两点（其实我有点冒风险的，本人也是 TPer 一枚，毕竟这是TP的官网）：</p><p> 1）客户端一般对服务端的响应速度有极高要求，因此，使用最原生态的 PHP 完成接口开发，是最高效的，假如用到了框架，还需要加载各种不需要多余的文件，就好比夏天穿了件冬天的衣服。试想，你在玩手机的时候，使用一个应用随便一个操作，等半天才有动静，你受的了吗？</p><p> 2）就是上面第4点提到的，框架对于WEB开发，是件很幸福的事，但对于 API 而言，你实在不敢想象它会给你出什么岔子！最后你将痛苦不堪~~因为很多框架都是为 WEB 诞生的（我也很期待有一天能看到专门为开发 API 而生的框架或者扩展）</p></li></ol><p>这个也有人纠结，接口效率与稳定性，还得看编码的人，有的人可能写的还不如框架跑的快，也有人觉得用框架没什么问题，这里只是建议，关键看自己的实际情况，同时建议代码上线前压测一下。</p><p>参考：</p><ol><li><a href="https://www.cnblogs.com/hnbiao/p/6545104.html" target="_blank" rel="external">api 接口开发理论 在php中调用接口以及编写接口</a></li><li><a href="https://blog.csdn.net/fmyzc/article/details/78798684" target="_blank" rel="external">php的api接口</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;如何使用 PHP 开发 API（Application Programming Interface，应用程序编程接口） 呢？&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识——互斥和死锁</title>
    <link href="http://yoursite.com/2018/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E5%92%8C%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2018/08/20/操作系统知识——互斥和死锁/</id>
    <published>2018-08-20T05:34:38.000Z</published>
    <updated>2018-08-20T03:15:08.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>银行家算法是最有代表性的<strong>避免死锁算法</strong>，是Dijkstra提出的。这是由于该算法能用于<strong>银行系统现金贷款</strong>的发放而得名。</p><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><ul><li><p><strong>关于安全状态的概述</strong></p><p>  <strong>系统处于安全状态时，一定不会发生死锁；系统处于不安全状态时，不一定会发生死锁；</strong></p><p>  （1）<strong>安全状态</strong><br>  如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p><p>  （2）<strong>不安全状态</strong><br>  不存在一个安全序列。不安全状态不一定导致死锁。</p></li><li><p><strong>基本思想</strong>：</p><p>  银行家可以把一定数量的资金供多个用户周转使用,为保证资金的安全,银行家<strong>规定</strong>:</p><ul><li>当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客;</li><li>顾客可以分期贷款,但贷款的总数不能超过最大需求量;</li><li>当银行家现有的资金不能满足顾客尚需的贷款数额时,对顾客的贷款可推迟支付,但总能使顾客在有限的时间里得到贷款;</li><li><p>当顾客得到所需的全部资金后,一定能在有限的时间里归还所有的资金.</p><p>银行家算法是通过动态地检测系统中资源分配情况和进程对资源的需求情况来决定如何分配资源的，在能确保系统处于安全状态时才能把资源分配给申请者，从而避免系统发生死锁。</p></li></ul></li><li><p><strong>相关的变量</strong>：</p><ul><li><strong>Available</strong>（可利用资源总数）<pre><code>某类可利用的资源数目，其初值是系统中所配置的该类全部可用资源数目。</code></pre></li><li><strong>Max</strong>：某个进程对某类资源的最大需求数</li><li><strong>Allocation</strong>： 某类资源已分配给某进程的资源数。</li><li><strong>Need</strong>：某个进程还需要的各类资源数。<pre><code>Need= Max-Allocation</code></pre></li></ul></li><li><p><strong>银行家算法描述</strong></p><p>设Request i是进程Pi的申请向量，如果Request i[j]=K,则表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p><ul><li><p>如果Request i[j]&lt;=Need[i,j]，便转向步骤2）；否则认为出错，因为它所需要的资源数已经超过它所宣布的最大值。</p></li><li><p>如果Request i[j]&lt;=Available[i,j]，便转向步骤3）；否则，表示尚无足够资源，Pi需等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Available[j]:=Available[j]-Request i[j];</div><div class="line">Allocation[i,j]:=Allocation[i,j]+Request i[j];</div><div class="line">Need[i,j]:=Need[i,j]-Request i[j];</div></pre></td></tr></table></figure></li></ul></li></ul><p>4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p><p>参考：<a href="https://www.cnblogs.com/Lynn-Zhang/p/5672080.html" target="_blank" rel="external">银行家算法</a></p><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>　　死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ul><li><p><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p><strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p><strong>循环等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></li></ul><h2 id="针对死锁的解决方案"><a href="#针对死锁的解决方案" class="headerlink" title="针对死锁的解决方案"></a>针对死锁的解决方案</h2><ol><li><p><strong>预防死锁</strong>。</p><p> 这是一种较简单和直观的事先预防的方法。方法是通过<strong>设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁</strong>。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</p><p> 预防死锁方法（3种）：</p><ul><li>破坏请求和保持条件，如<strong>资源静态分配法</strong>（也称为预分配资源）</li><li>破坏不可抢占条件</li><li>破坏循环等待条件</li></ul></li></ol><ol><li><p><strong>避免死锁</strong>。</p><p> 该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在<strong>资源的动态分配过程</strong>中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。如<a href="https://www.cnblogs.com/Lynn-Zhang/p/5672080.html" target="_blank" rel="external"><strong>银行家算法</strong></a></p></li></ol><ol><li><p><strong>检测死锁</strong>。</p><p> 这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。如<a href="http://blog.csdn.net/nima1994/article/details/65657250" target="_blank" rel="external"><strong>资源分配图简化法</strong></a>。</p></li></ol><ol><li><p><strong>解除死锁</strong>。</p><p> 这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须<strong>将进程从死锁状态中解脱出来</strong>。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p><p> 死锁的解除方法（2种）：</p><ul><li>抢占资源，如<strong>剥夺资源法</strong>。</li><li>终止（或撤销）进程。</li></ul></li></ol><p>具体方案：</p><ol><li><strong>抢占式资源分配策略</strong> ：要使不可抢占其它进程占有的资源不成立，可以约定如下：如果一个进程已经占有了某些资源又要申请新资源，而新资源不能满足必须等待时，系统可以抢夺该进程已有的资源。 它只适合于主存和处理器。</li><li></li><li><strong>释放已占资源策略</strong>——这种分配策略是仅当进程没有占有资源时才允许它去申请资源。如果进程已占用了某些资源而又要再申请资源，则它应先归还所占的资源后再申请新资源。</li><li><strong>按序分配资源</strong>——要使循环等待条件不成立可采用按序分配的资源分配策略。具体做法是把系统中所有资源排序，对每个资源确定一个编号，规定任何一个进程申请两个以上的资源时，总是先申请编号最小的资源，再申请编号大的资源。</li><li>关于 </li></ol><p>链接：<a href="https://www.nowcoder.com/questionTerminal/b8ade2458fe94e59827f8adbf58efe2c" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/b8ade2458fe94e59827f8adbf58efe2c</a><br>来源：牛客网</p><h2 id="系统中的资源"><a href="#系统中的资源" class="headerlink" title="系统中的资源"></a>系统中的资源</h2><ul><li>一类是<strong>可剥夺资源</strong>，即<strong>CPU 和 内存</strong> ，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的 处理机 。</li><li>另一类资源是<strong>不可剥夺资源</strong>，如 <strong>磁带机 、打印机等</strong>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放。</li></ul><p>链接：<a href="https://www.nowcoder.com/questionTerminal/d7375249214648c6b3b12ce8184efea2" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/d7375249214648c6b3b12ce8184efea2</a><br>来源：牛客网</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>各进程采取互斥的方式，实现共享的资源称作临界资源。</p><p>信号量机制的引入解决了进程同步的描述问题，但信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁。如：生产者消费者问题中将P、V颠倒可能死锁。<br>为此Dijkstra于1971年提出：把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/401d52fe872a4473857f8b795ccc6783" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/401d52fe872a4473857f8b795ccc6783</a><br>来源：牛客网</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;银行家算法&quot;&gt;&lt;a href=&quot;#银行家算法&quot; class=&quot;headerlink&quot; title=&quot;银行家算法&quot;&gt;&lt;/a&gt;银行家算法&lt;/h2&gt;&lt;p&gt;银行家算法是最有代表性的&lt;strong&gt;避免死锁算法&lt;/strong&gt;，是Dijkstra提出的。这是由于该算法能用
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="互斥与死锁" scheme="http://yoursite.com/tags/%E4%BA%92%E6%96%A5%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>C++输入函数的应用</title>
    <link href="http://yoursite.com/2018/08/20/C++%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/20/C++输入函数的应用/</id>
    <published>2018-08-20T05:34:38.000Z</published>
    <updated>2018-08-20T04:19:49.710Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为找工作的事情，在刷一些编程题，也陆陆续续参加了一些笔试，一般编程中使用的语言是C++，因为编程题会有时间的限制，C++的效率最高，不容易出现超时的问题所以使用最多的语言就是C++。</p><p>在编程中，其中最容易遇到的问题就是输入问题。下面就讨论一下C++常用的一些输入函数。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++中几个输入函数有：</p><ul><li>cin</li><li>cin.get()</li><li>cin.getline()</li><li>getline()</li><li>gets()</li><li>getchar()</li></ul><h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><ul><li><p>输入数字，以“回车”或者空格结束</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a,b;</div><div class="line">cin&gt;&gt;a&gt;&gt;b;  // 按行输入对应的参数</div><div class="line">cout&lt;&lt;a+b&lt;&lt;endl;</div></pre></td></tr></table></figure></li><li><p>输入一个字符串，遇“空格”、“TAB”、“回车”都结束</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a[20];</div><div class="line">cin&gt;&gt;a;</div><div class="line">cout&lt;&lt;a&lt;&lt;endl;</div></pre></td></tr></table></figure></li></ul><h2 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h2><ul><li><p><code>cin.get(str)</code>可以用来接收字符，str为字符数组名。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char ch;</div><div class="line">ch=cin.get(); //或者cin.get(ch);只能获取一个字符</div><div class="line">cout&lt;&lt;ch&lt;&lt;endl;</div></pre></td></tr></table></figure></li><li><p><code>cin.get(str,n)</code>用来接收一行字符串,可以接收空格，str为字符数组名，n为接收字符数目。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a[20];</div><div class="line">cin.get(a,20); //有些类似getline。可以输入多个单词，中间空格隔开。</div><div class="line">cout&lt;&lt;a&lt;&lt;endl;</div></pre></td></tr></table></figure></li><li><p><code>cin.get()</code>没有参数主要是用于舍弃输入流中的不需要的字符,或者舍弃回车,弥补cin.get(字符数组名,接收字符数目)的不足.</p></li></ul><h2 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h2><ul><li><p>接受一个字符串，可以接收空格并输出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char m[20];</div><div class="line">cin.getline(m,5); //与上面基本相同。</div><div class="line">cout&lt;&lt;m&lt;&lt;endl;</div></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入：jkljkljkl</div><div class="line">输出：jkljkljkl</div><div class="line"></div><div class="line">输入：jklf fjlsjf fjsdklf</div><div class="line">输出：jklf fjlsjf fjsdklf</div></pre></td></tr></table></figure></code></pre><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><ul><li><p>接受一个字符串，可以接收空格并输出，需包含<code>#include&lt;string&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string str;</div><div class="line">getline(cin,str);</div><div class="line">cout&lt;&lt;str&lt;&lt;endl;</div></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入：jkljkljkl //VC6中有个bug,需要输入两次回车。</div><div class="line">输出：jkljkljkl</div><div class="line"></div><div class="line">输入：jkl jfksldfj jklsjfl</div><div class="line">输出：jkl jfksldfj jklsjfl</div></pre></td></tr></table></figure></code></pre><h2 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h2><ul><li><p>接受一个字符串，可以接收空格并输出，需包含<code>#include&lt;string&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char m[20];</div><div class="line">gets(m); //不能写成m=gets();</div><div class="line">cout&lt;&lt;m&lt;&lt;endl;</div></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入：jkljkljkl</div><div class="line">输出：jkljkljkl</div><div class="line"></div><div class="line">输入：jkl jkl jkl</div><div class="line">输出：jkl jkl jkl</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 多维输入</div><div class="line">char m[3][20];</div><div class="line">for(int i=0;i&lt;3;i++)</div><div class="line">&#123;</div><div class="line">    cout&lt;&lt;&quot;\n请输入第&quot;&lt;&lt;i+1&lt;&lt;&quot;个字符串：&quot;&lt;&lt;endl;</div><div class="line">    gets(m[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">cout&lt;&lt;endl;</div><div class="line">for(int j=0;j&lt;3;j++)</div><div class="line">    cout&lt;&lt;&quot;输出m[&quot;&lt;&lt;j&lt;&lt;&quot;]的值:&quot;&lt;&lt;m[j]&lt;&lt;endl;</div></pre></td></tr></table></figure></code></pre><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h2><ul><li><p>/接受一个字符，需包含<code>#include&lt;string&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char ch;</div><div class="line">ch=getchar(); //不能写成getchar(ch);</div><div class="line">cout&lt;&lt;ch&lt;&lt;endl;</div></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输入：jkljkljkl</div><div class="line">输出：j</div><div class="line"></div><div class="line">//getchar()是C语言的函数，C++也可以兼容，但是尽量不用或少用；</div></pre></td></tr></table></figure></code></pre><h2 id="常用的应用"><a href="#常用的应用" class="headerlink" title="常用的应用"></a>常用的应用</h2><ul><li><p>输入单个数字</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a;</div><div class="line">cin &gt;&gt; a;</div></pre></td></tr></table></figure></li><li><p>输入多个数字</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">   // 默认是空格或者回车键为间隔</div><div class="line">   int a, b;</div><div class="line">   cin &gt;&gt; a &gt;&gt; b;</div><div class="line">   </div><div class="line">   </div><div class="line">   // 以逗号隔开的多个数字输入</div><div class="line">   int n, m;</div><div class="line">   </div><div class="line">cin &gt;&gt; n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (cin.get() == &apos;,&apos;) &#123;</div><div class="line">cin &gt;&gt; m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>输入一维数组（默认以空格为间隔）,<code>#include &lt;vector&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   vector&lt;int&gt; arr(n, 0);</div><div class="line">   </div><div class="line">for (int i = 0; i &lt; m; i++)&#123;</div><div class="line">cin &gt;&gt; arr[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>输入二维数组（默认以空格为间隔）,<code>#include &lt;vector&gt;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   vector&lt;vector&lt;int&gt;&gt; arr(m, vector&lt;int&gt;(n, 0));</div><div class="line">   </div><div class="line">for (int i = 0; i &lt; m; i++)&#123;</div><div class="line">for (int j = 0; j &lt; n; j++)&#123;</div><div class="line">cin &gt;&gt; arr[i][j];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>以<code>,</code>为间隔的输入数组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 二维数组，以逗号为间隔</div><div class="line">vector&lt;vector&lt;int&gt;&gt; S(n, vector&lt;int&gt;(m, 0));</div><div class="line"></div><div class="line">for (int i = 0; i &lt; n; i++)&#123;</div><div class="line">cin &gt;&gt; S[i][0];</div><div class="line">for (int j = 1; j &lt; m; j++)&#123;</div><div class="line">if (cin.get() == &apos;,&apos;) &#123;</div><div class="line">cin &gt;&gt; S[i][j];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>输入不定长的数组（检测回车键）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   // 定义二维数组</div><div class="line">vector&lt;vector&lt;int&gt;&gt; F(n, vector&lt;int&gt;(n, -1));</div><div class="line"></div><div class="line">for (int i = 0; i &lt; n; i++)&#123;</div><div class="line">for (int j = 0; j &lt; n; j++) &#123;</div><div class="line">int temp;</div><div class="line">cin &gt;&gt; temp;</div><div class="line">F[i][j] = temp;</div><div class="line">if (cin.get() == &apos;\n&apos;)</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>输入字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   // 已知字符串的长度，注意最后一位是\0</div><div class="line">   char a[21];</div><div class="line">cin &gt;&gt; a;</div><div class="line">cout &lt;&lt; a &lt;&lt; endl;</div></pre></td></tr></table></figure></li></ul><blockquote><p>输入的时候需要加入越界检测如下，需要<code>0&lt;=n&lt;=100</code>。</p></blockquote><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   if ((n &lt; 0) || (n &gt; 100)) &#123;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>参考：<a href="https://blog.csdn.net/ahzz123/article/details/70495617/" target="_blank" rel="external">C++中输入字符串的几种方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为找工作的事情，在刷一些编程题，也陆陆续续参加了一些笔试，一般编程中使用的语言是C++，因为编程题会有时间的限制，C++的效率最高，不容易出现超时的问题所以使用最多的语言就是C++。&lt;/p&gt;
&lt;p&gt;在编程中，其中最容易遇到的问题就是输入问题。下面就讨论一下C++常用的
      
    
    </summary>
    
      <category term="求职面试" scheme="http://yoursite.com/categories/%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>http请求流程</title>
    <link href="http://yoursite.com/2018/08/19/http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/19/http请求流程/</id>
    <published>2018-08-19T12:22:38.000Z</published>
    <updated>2020-06-26T15:20:20.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hhtp请求流程"><a href="#hhtp请求流程" class="headerlink" title="hhtp请求流程"></a>hhtp请求流程</h2><p>首先http是一个<strong>应用层的协议</strong>，在这个层的协议，只是一种通讯规范，也就是因为双方要进行通讯，大家要事先约定一个规范。</p><p>http请求与响应的步骤如下：</p><ul><li><p><strong>URL解析、域名解析</strong><br>  输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP。如果url里不包含端口号，则会使用协议的默认端口号。</p><p>  浏览器根据访问的域名找到其IP地址。DNS查找过程如下：</p><p>  1）浏览器缓存：浏览器会缓存DNS记录一段时间。 但操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</p><p>  2）系统缓存：如果在浏览器缓存里没有找到需要的域名，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。</p><p>  3）路由器缓存：如果系统缓存也没找到需要的域名，则会向路由器发送查询请求，它一般会有自己的DNS缓存。</p><p>  4）ISP DNS缓存：如果依然没找到需要的域名，则最后要查的就是ISP缓存DNS的服务器。在这里一般都能找到相应的缓存记录。</p></li><li><p><strong>产生请求数据</strong></p><p>  根据返回的IP和URL解析得到的参数，结合应用层的协议，确定发送的数据内容，将这些数据放到一个缓冲区内，然后形成了应用层的报文data。</p><p>  此时，将应用层的报文data发送到传输层。经过传输层处理，如报文打上了传输头的包头（主要包含端口号，以及tcp的各种信息），得到tcp的数据传送单位segment。</p></li><li><p><strong>建立网络连接并发送请求包</strong> </p><p>  拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024&lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。</p><p>  采用<strong>ip地址＋协议＋端口号</strong>唯一标示网络中的一个进程，利用socket进行通信。基于socket进行TCP三次握手，建立TCP连接。然后浏览器发起了http的请求。</p><p>  将传输层的数据段送到网络层，在网络层被打包，这样封装上了网络层的包头，包头内部含有源及目的的ip地址，该层数据发送单位被称为packet。网络层开始负责将这样的数据包在网络上传输，如何穿过路由器，最终到达目的地址。</p></li></ul><ul><li><p><strong>返回响应数据</strong></p></li><li><p>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</p></li><li><p>浏览器对页面进行渲染呈现给用户</p></li><li><p><strong>断开网络连接</strong></p><p> 若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li></ul><h2 id="HTTP请求格式和返回格式"><a href="#HTTP请求格式和返回格式" class="headerlink" title="HTTP请求格式和返回格式"></a>HTTP请求格式和返回格式</h2><ul><li><p><strong>请求格式</strong></p><p>  HTTP请求格式主要有四部分组成，分别是：<strong>请求行、请求头、空行、消息体</strong>，每部分内容占一行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;request-line&gt;</div><div class="line">&lt;general-headers&gt;</div><div class="line">&lt;request-headers&gt;</div><div class="line">&lt;entity-headers&gt;</div><div class="line">&lt;empty-line&gt;    // (用于分割请求头和消息体)</div><div class="line">[&lt;message-body&gt;]</div></pre></td></tr></table></figure><ul><li><p>请求行中包含的请求方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET: 完整请求一个资源 （常用）</div><div class="line">HEAD: 仅请求响应首部</div><div class="line">POST：提交表单 （常用）</div><div class="line">PUT: 上传</div><div class="line">DELETE：删除</div></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>响应格式</strong></p><p>  为了告知浏览器，Web服务器首先传送一些HTTP头信息，然后传送具体内容（即HTTP体信息），HTTP头信息和HTTP体信息之间用一个空行分开</p><p>  HTTP响应格式<br>服务器接收处理完请求后返回一个HTTP相应消息给客户端。HTTP响应消息的格式包括：<strong>状态行、响应头、空行、消息体</strong>。每部分内容占一行。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;status-line&gt;</div><div class="line">&lt;general-headers&gt;</div><div class="line">&lt;response-headers&gt;</div><div class="line">&lt;entity-headers&gt;</div><div class="line">&lt;empty-line&gt;</div><div class="line">[&lt;message-body&gt;]</div></pre></td></tr></table></figure></li></ul><pre><code>常用的HTTP头信息有（[一个http请求的详细过程](https://www.jianshu.com/p/aa97810e5fa4)）：① HTTP 1.0 200 OK 　这是Web服务器应答的第一行，列出服务器正在运行的HTTP版本号和应答代码。代码&quot;200 OK&quot;表示请求完成。② MIME_Version:1.0　它指示MIME类型的版本。③ content_type:类型　这个头信息非常重要，它指示HTTP体信息的MIME类型。如：content_type:text/html指示传送的数据是HTML文档。④ content_length:长度值　它指示HTTP体信息的长度（字节）。</code></pre><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>WEB Server都是基于Socket编程，又称之为网络编程，网络协议通过一个叫做socket的对象抽象出来，<strong>socket可以建立网络连接，读数据，写数据</strong>。socket模块定义了一些常量参数，用来指定socket的的地址族、socket的类型、以及支持的TCP/IP协议。</p><p>利用<strong>ip地址＋协议＋端口号</strong>唯一标示网络中的进程，然后利用socket进行通信。</p><p>socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p>通常传输层的服务通过系统调用的方式提供，以socket的方式。对于客户端，要想建立一个socket连接，需要调用这样一些函数socket() bind() connect(),然后就可以通过send()进行数据发送。</p><p>参考：</p><ol><li><a href="https://foofish.net/http-request-process.html" target="_blank" rel="external">一次完整的HTTP请求过程</a></li><li><a href="https://www.jianshu.com/p/aa97810e5fa4" target="_blank" rel="external">一个http请求的详细过程</a></li><li><a href="https://blog.csdn.net/lvyuan30276/article/details/50458572" target="_blank" rel="external">TCP与SOCKET的三次握手的对应关系</a></li><li><a href="https://www.cnblogs.com/suntp/p/6434644.html" target="_blank" rel="external">三次握手 四次握手 与socket函数的关系</a></li><li><a href="https://blog.csdn.net/lzghxjt/article/details/51458540" target="_blank" rel="external">http请求与响应全过程</a></li><li><a href="https://jackchan1999.github.io/2017/04/30/java/%E5%86%99%E7%BB%99%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E7%B3%8A%E9%87%8C%E7%B3%8A%E6%B6%82%E7%9A%84HTTP%E3%80%81TCP%E3%80%81UDP%E3%80%81Socket/" target="_blank" rel="external">写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hhtp请求流程&quot;&gt;&lt;a href=&quot;#hhtp请求流程&quot; class=&quot;headerlink&quot; title=&quot;hhtp请求流程&quot;&gt;&lt;/a&gt;hhtp请求流程&lt;/h2&gt;&lt;p&gt;首先http是一个&lt;strong&gt;应用层的协议&lt;/strong&gt;，在这个层的协议，只是一种通
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>PHP自动加载机制</title>
    <link href="http://yoursite.com/2018/08/17/PHP%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/17/PHP自动加载机制/</id>
    <published>2018-08-17T13:19:38.000Z</published>
    <updated>2018-08-20T04:26:11.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，为什么PHP需要自动加载呢？</p><p>在PHP面向对象(OO)编程中，为了方便管理，我们都会把一个类写在一个单独的文件中，那么如果想在A类中使用B类的功能，就需要把B类加载到A类。对于这样的需求在最原始的时候，我们是通过require 和 include 语法实现将文件加载到另一个文件中，include 和 require 是PHP中引入文件的两个基本方法。</p><p>在小规模开发中直接使用 include 和 require 不会有什么不妥，但在大型项目中会造<strong>成大量的 include 和 require 堆积</strong>。这样的代码既不优雅，执行效率也很低，而且维护起来也相当困难。</p><p>PHP的自动加载功能，框架实现自动加载的包括<strong>PHP规范中的PSR0和PSR4原则，Composer的自动加载</strong>功能等等。</p><p><strong>php加载文件方式</strong>：</p><ol><li><strong>常规加载</strong>：include,include_once,requice,requice_one</li><li><strong>魔法方法</strong>：__autoload()</li><li><strong>SPL 自动加载</strong>：spl_autoload_register()</li></ol><h2 id="include-与require"><a href="#include-与require" class="headerlink" title="include()与require()"></a>include()与require()</h2><p>简单的文件加载方法：</p><ol><li><p><strong>require()</strong></p><p> 包含的意思，找不到文件时，会报warning的错误，然后程序继续往下执行。include语句只有在被执行时才会读入要包含的文件。在错误处理方便，使用include语句，如果发生包含错误，程序将跳过include语句，虽然会显示错误信息但是程序还是会继续执行！php处理器会在每次遇到include()语句时，对它进行重新处理，所以可以根据不同情况的，在条件控制语句和循环语句中使用include()来包含不同的文件。</p></li><li><p><strong>include()</strong></p><p> 必须的意思，找不到文件时，会报fatal error（致命错误），程序停止往下执行。在php文件被执行之前，php解析器会用被引用的文件的全部内容替换require语句，然后与require语句之外的其他语句组成个新的php文件，最好后按新的php文件执行程序代码。</p></li><li><p><strong>require_once()</strong></p><p> 类似于include()，系统会进行判断，如果已经包含，则不会再包含第二次。</p></li><li><p><strong>include_once()</strong></p><p> 类似于require()，系统会进行判断，如果已经包含，则不会再包含第二次。</p></li></ol><p>– <strong>共同点</strong>：能包含位于独立文件中的代码，可以减少代码的重复，实现代码结构的模块化，方便调用。</p><ul><li><p><strong>注意事项</strong>：</p><ul><li><p><strong>加载文件格式</strong></p><p>  include/require 包含进来的文件必须要加<code>&lt;?php ?&gt;</code>因为在包含时,首先理解文件内容是普通字符串,碰到<code>&lt;?php ?&gt;</code>标签时,才去解释。</p></li><li><p><strong>路径要求</strong></p><p>  可以用绝对路径，也可以用相对路径；windows下正反斜线都可以，linux下只认正斜线，所以最好用正斜线。</p></li><li><p><strong>如何选择</strong></p><p>  比如是系统配置，缺少了，网站不让运行，自然用require，如果是某一段统计程序，少了，对网站只是少统计人数罢了，不是必须要的，可以用include而加不加once是效率上的区别，加上once，虽然系统帮你考虑了只加载一次，但系统的判断会是效率降低，因此，更应该在开发之初，就把目录结构调整好，尽量不要用_once的情况。</p></li><li><p><strong>特殊用法</strong></p><p>  利用include/require返回被包含页面的返回值</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.php页面中: ..... return $value; </div><div class="line">b.php页面中:$v = include(&quot;a.php&quot;);</div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="autoload-自动加载"><a href="#autoload-自动加载" class="headerlink" title="__autoload()自动加载"></a>__autoload()自动加载</h2><ul><li><p><strong>PHP5及之后的版本</strong>，使用尚未定义的类时会自动调用__autoload函数，所以我们可以通过编写__autoload函数来让php自动加载类，而不必写一个长长的包含文件列表。</p><p>  需明确的是对于__autoload()函数，PHP在找不到类的时候会自动执行，但是PHP内部并没有定义这个函数。</p><p>  <strong>这个函数需要开发者自定义，并且编写内部逻辑，PHP只负责在需要的时候自动调用执行</strong>。而且在调用的时候会自动传人要加载的类名作为参数。</p></li><li><p><strong>用法</strong>：首先需要在需要加载文件的代码中，定义__autoload()函数，并且编写内部逻辑。PHP在找不到类的时候会自动执行__autoload()函数。下面是A.php需要加载B.php的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//文件 B.php 不做修改</div><div class="line">//文件 A.php</div><div class="line">&lt;?php</div><div class="line">class A&#123;</div><div class="line">    public function test()&#123;</div><div class="line">        $b_object = new B();</div><div class="line">        $b_object-&gt;echo_info();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function __autoload($classname)&#123;</div><div class="line">    require $classname.&apos;.php&apos;;//include &apos;b.php&apos;;</div><div class="line">&#125;</div><div class="line">$a_object = new A();</div><div class="line">$a_oject-&gt;test();</div><div class="line">?&gt;</div><div class="line">命令行输入：#php a.php</div><div class="line">    输出： “我是class B中的方法执行结果“</div></pre></td></tr></table></figure></li><li><p><strong>缺陷</strong>：一个项目中仅能有一个这样的 __autoload() 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个__autoload()函数文件，否则会报致命错误。</p><p>  如果项目比较大，加载每个文件都使用同样的规则显然是不现实的，那么我们可能就需要在__autoload()中编写复杂的规则逻辑来满足加载不同文件的需求。</p><p>  这同样会<strong>使得__autoload()函数变得复杂臃肿，难以维护管理</strong>。</p></li></ul><h2 id="SPL-自动加载"><a href="#SPL-自动加载" class="headerlink" title="SPL 自动加载"></a>SPL 自动加载</h2><p>PHP在实例化一个对象时（实际上在实现接口，使用类常数或类中的静态变量，调用类中的静态方法时都会如此），首先会在系统中查找该类（或接口）是否存在，如果不存在的话就尝试使用autoload机制来加载该类。而autoload机制的主要执行过程为：</p><ul><li>检查执行器全局变量函数指针autoload_func是否是NULL；</li><li>如果 autoload_func==NULL ,则查找系统是否定义 __autoload() 函数，如果定义了，则执行并返回加载结果。如果没有定义，则报错并退出；</li><li>如果 autoload_func 不等于NULL，则直接执行 autoload_func 指向的函数加载类，此时并不检查 __autoload() 函数是否定义。</li></ul><blockquote><p>通过上述PHP自动加载流程，可知PHP实际上提供了两种方法来实现自动装载机制：（1）使用用户定义的__autoload()函数，这通常在PHP源程序中来实现；（2）设计一个函数，将autoload_func指针指向它，这通常使用C语言在PHP扩展中实现，即 SPL autoload机制，即本节中的SPL自动加载。如果两种方式都实现了，也就是 autoload_func 不等于NULL，程序只会执行第二种方式，__autoload() 函数是不会被执行的。</p></blockquote><ul><li><p>用法</p><p>  通过<code>spl_autoload_register(&#39;my_autoload&#39;)</code>，实现了 当程序执行找不到类B时，会执行 自定义的 <code>my_autoload()</code>函数，加载B类。实际上 <code>spl_autoload_register(&#39;my_autoload&#39;)</code> 的作用就是 把autoload_func 指针指向 <code>my_autoload()</code>。</p><p>  示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">B.php文件不变</div><div class="line">A.php</div><div class="line">&lt;?php</div><div class="line">class A&#123;</div><div class="line">    public function test()&#123;</div><div class="line">        $b_object = new B();</div><div class="line">        $b_object-&gt;echo_info();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function __autoload($classname)&#123;</div><div class="line">    require $classname.&apos;.php&apos;;//include &apos;b.php&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function my_autoload($classname)&#123;</div><div class="line">    require $classname.&apos;.php&apos;;//include &apos;b.php&apos;;</div><div class="line">    echo &apos;my_autoload   &apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spl_autoload_register(&apos;my_autoload&apos;);</div><div class="line">$a_object = new A();</div><div class="line">$a_object-&gt;test();</div><div class="line"></div><div class="line">结果：my_autoload  我是class B中的方法执行结果</div><div class="line">?&gt;</div></pre></td></tr></table></figure></li><li><p><strong>SPL 自动加载整个过程</strong></p><p>  针对上述的示例，假如把<code>spl_autoload_register(&#39;my_autoload&#39;)</code>改成 <code>spl_autoload_register()</code>不添加任何参数，B类也能被加载。 </p><p>  为什么呢？</p><p>  因为SPL扩展内部自己定义了一个自动加载函数 <code>spl_autoload()</code>,实现了自动加载的功能，如果我们不定义自己的自动加载函数，并且程序里写了<code>spl_autoload_register()</code>（如果不传参数，必须是第一次执行才会有效）或者 <code>spl_autoload_register(&#39;spl_autoload&#39;)</code>，那么autoload_func 指针就会指向内部函数 <code>spl_autoload()</code>。程序执行的时候如果找不到相应类就会执行该自动加载函数。</p><p>  <strong>SPL 是怎么实现autoload_func 指针指向不同的函数呢？</strong></p><p>  在SPL内部定义了 一个函数 <code>spl_autoload_call()</code> 和 一个全局变量<code>autoload_functions</code>。<code>autoload_functions</code>本质上是一个HashTable，不过我们可以将其简单的看作一个链表，链表中的每一个元素都是一个函数指针,指向一个具有自动加载类功能的函数。</p><p>  <code>spl_autoload_call()</code>的作用就是按顺序遍历 <code>autoload_functions</code>，使得autoload_func指向每个自动加载函数，如果加载成功就停止，如果不成功就继续遍历下个自动加载函数，直到加载成功或者遍历完所有的函数。</p><p>  <strong>autoload_functions 这个列表是谁来维护的呢？</strong></p><p>  由<code>spl_autoload_register()</code> 这个函数维护。我们说的自动加载函数的注册，其实就是通过·spl_autoload_register()·把自动加载函数加入到<code>autoload_functions</code> 列表。</p><p>  <strong>相关SPL自动加载函数</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spl_autoload_functions() //打印autoload_functions列表</div><div class="line">  spl_autoload_unregister() //注销自动加载函数</div></pre></td></tr></table></figure></li></ul><p>参考：</p><ol><li><a href="https://blog.csdn.net/weixin_37356656/article/details/78642520" target="_blank" rel="external">PHP-自动加载原理分析</a></li><li><a href="https://m.jb51.net/article/81905.htm" target="_blank" rel="external">php自动加载方式集合</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，为什么PHP需要自动加载呢？&lt;/p&gt;
&lt;p&gt;在PHP面向对象(OO)编程中，为了方便管理，我们都会把一个类写在一个单独的文件中，那么如
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="自动加载" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>mysql中as用法</title>
    <link href="http://yoursite.com/2018/08/10/mysql%E4%B8%ADas%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/10/mysql中as用法/</id>
    <published>2018-08-10T09:19:38.000Z</published>
    <updated>2018-08-20T04:00:27.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重命名列名或者表名。"><a href="#重命名列名或者表名。" class="headerlink" title="重命名列名或者表名。"></a>重命名列名或者表名。</h2><p>as可理解为：用作、当成，作为；一般是重命名列名或者表名。（主要为了查询方便）</p><ul><li><p><strong>重命名列</strong>。如：表text，  列 column_1,column_2  你可以写成：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select  column_1  as  列1,column_2 as  列2   from  text as  表;</div></pre></td></tr></table></figure><blockquote><p>上面的语句可以解释为：选择 column_1  作为   列1，column_2 作为   列2  从 text  当成  表。</p></blockquote></li></ul><ul><li><p><strong>重命名表</strong>。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from blog as B;</div><div class="line">select *from B;</div></pre></td></tr></table></figure><blockquote><p>解析：查找所有blog 表里面的数据，并把blog表格命名为 B；当你命名一个表之后，你可以在下面用 B 代替 blog；</p></blockquote></li></ul><h2 id="连接语句的操作符"><a href="#连接语句的操作符" class="headerlink" title="连接语句的操作符"></a>连接语句的操作符</h2><ul><li><p>as可以作为连接语句的操作符。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create table  tablename as select * from tablename2;</div></pre></td></tr></table></figure><blockquote><p>解释：上面语句的意思就是先获取到tablename表中的所有记录，之后创建一张tablename表，结构和tablename2表相同，记录为后面语句的查询结果。</p></blockquote></li></ul><p>参考：<a href="https://blog.csdn.net/username_lx/article/details/77184051" target="_blank" rel="external">mysql中as用法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重命名列名或者表名。&quot;&gt;&lt;a href=&quot;#重命名列名或者表名。&quot; class=&quot;headerlink&quot; title=&quot;重命名列名或者表名。&quot;&gt;&lt;/a&gt;重命名列名或者表名。&lt;/h2&gt;&lt;p&gt;as可理解为：用作、当成，作为；一般是重命名列名或者表名。（主要为了查询方便
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="http://yoursite.com/2018/07/11/%E7%BC%93%E5%AD%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/11/缓存学习笔记/</id>
    <published>2018-07-11T11:41:38.000Z</published>
    <updated>2018-08-20T03:23:36.837Z</updated>
    
    <content type="html"><![CDATA[<p>最近在狂补优化方面的知识，缓存也是优化的一大方向。之前关于缓存只是知道它的功能，再多不知道了，这里整理缓存相关的知识，算是优化入门吧。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p><strong>缓存</strong></p><p>  是“存贮<strong>使用频繁的数据</strong>的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。”</p><p>  缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键 ID）。</p></li><li><p><strong>缓存分类</strong> </p><ul><li><p><strong>硬件缓存</strong></p><p>  它指的是一块芯片，可以被集成到硬盘或者是CPU上。它的作用就是充当硬盘（CPU）与外界接口（通常是内存）之间的暂存器。利用缓存可以减轻系统的负荷，同时提高数据的传输速率，如硬盘缓存和CPU缓存。</p></li><li><p><strong>客户端缓存</strong>：</p><p>  某些应用，如浏览器，手机淘宝等，为了实现能够快速响应用户的请求，会把用户之前浏览的东西（如图片等）存在本地。在下次访问时，如果本地的缓存里有请求的内容，那么就直接展示出来，不用再次向服务器请求。</p></li><li><p><strong>服务端缓存</strong>：</p><p>  它与客户端缓存目的相同，只不过是站在服务器这边考虑的。如果每次接到客户端请求都要连接一次数据库，当用户请求多的时候，负载过大。这时可以把一些经常被请求的数据存放在内存中，当有请求时直接返回，不用经过数据库。这样就可以减轻数据库的负担。</p></li></ul></li><li><p><strong>缓存的工作原理</strong></p><p>  当客户端向服务器请求一个资源时，服务器首先在缓存中找，如果在缓存中，那么直接返回，不需要连接数据库；如果请求的资源不在缓存中，这时再去数据库中找，找到后返回给客户端，并将这个资源加入缓存中。</p></li><li><p><strong>命中（HIT）</strong></p><p>  当客户发端起一个请求，如果被请求的资源在缓存中，这个资源就会被使用，我们就叫它缓存命中。</p></li><li><p><strong>未命中（MISS）</strong></p><p>  当客户端发起一个请求，如果没有在缓存中找到，我们称这种情况为缓存未命中。这时就需要查询数据库，并且将查询结果加入缓存中。　</p></li><li><p><strong>存储成本</strong></p><p>  当未命中时，我们会从数据库取出数据，然后加入缓存。把这个数据放入缓存所需要的时间和空间，就是存储成本。</p></li><li><p><strong>失效</strong></p><p>  当缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。</p><p>  一种是数据库中的数据发生了变化，那么如果这个数据在缓存，相应的缓存数据也要同步更新。例如原来 id=1 的编程语言叫 Java，结果管理员修改成了 PHP，那么缓存里面的 id=1 的值就要同步成最新的值。</p><p>  另一种情况是该缓存过了失效时间。因为缓存会占用内存，太多的缓存是不合理的，我们可以通过设置失效时间的方式让缓存定时过期失效。</p></li><li><p><strong>失效策略（缓存算法）</strong></p><p>  如果缓存满了，而当前请求又没有命中缓存，那么就会按照某一种策略，把缓存中的某个旧资源剔除，而把新的资源加入缓存。这些决定应该剔除哪个旧资源的策略统称为失效策略。</p></li><li><p><strong>替代策略</strong></p><p>  当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。</p></li><li><p><strong>最优替代策略</strong></p><p>  最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。</p></li></ul><h2 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h2><ul><li><p><strong>原则上，失效策略需要考虑到以下这几点</strong>：</p><ul><li><p><strong>成本</strong></p><p>  如果缓存对象有不同的存储成本，应该把那些难以获得的对象保存下来；</p></li><li><p><strong>容量</strong>：</p><p>  如果缓存对象有不同的大小，应该把那些大的缓存对象清除，让更多的小缓存对象进来了；</p></li><li><p><strong>时间</strong></p><p>  一些缓存设定有过期时间，应该在到时间之后将它们失效。<br>  应该根据缓存对象的性质选择合适的失效策略，常见的失效策略有这么几种：</p><p>关于常见的缓存算法见博客：<a href="http://twei.site/2017/07/15/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5/" target="_blank" rel="external">缓存那些事–常用的缓存失效策略</a></p></li></ul></li></ul><h2 id="缓存中存在的问题"><a href="#缓存中存在的问题" class="headerlink" title="缓存中存在的问题"></a>缓存中存在的问题</h2><p>在缓存中存在缓存击穿、缓存雪崩、缓存并发等问题</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p><strong>问题描述</strong></p><p>  缓存穿透是指<strong>查询一个一定不存在的数据</strong>，此时缓存是不被把命中的，那么就需要查数据库来获取这个值并写入缓存后返回，但是由于在数据库中也没有这个值，所以结果也不会写入缓存中。这将导致这个存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>  在流量大的时候，可能数据库就崩溃了。另外要是有人利用不存在的 key 频繁请求数据库，这就是系统的漏洞。</p></li><li><p><strong>解决方法</strong>：常见的有两种：过滤器和设定指定值。</p><p>  （1）<strong>过滤器</strong></p><p>  最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p>  （2）<strong>设定指定值</strong></p><p>  这种方法比较巧妙，如果一个查询返回的数据为空（可能由于数据不存在，也可能是系统故障），我们仍然把这个空结果进行缓存，缓存的值设定为一个指定值，同时设置它的过期时间很短，最长不超过五分钟。（因为缓存会占用内存，长时间缓存一个不存在的值比较耗资源。）在这五分钟内，这个值可能由于写入操作从而不再是一个不存在的值，这是就要更新缓存，用真实值替代指定值。</p><p>  比如，设定不存在的值缓存为 &amp;&amp;，也就是 “key” ===&gt; “&amp;&amp;”。当返回这个 &amp;&amp; 值的时候，就可以认为这是不存在的 key，然后决定是继续等待访问，还是放弃掉这次操作。如果继续等待访问，那么经过一个时间轮询点后，再次请求这个 key，如果取到的值不再是 &amp;&amp;，则可以认为这时候 key 有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li><p><strong>问题描述</strong></p><p>  缓存雪崩指的是在某一个时刻，<strong>大量缓存同时失效</strong>，请求全部转到了数据库，导致数据库压力过大。</p><p>  引起这个问题的主要原因还是高并发。平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟后或5分钟后。当并发很高时，会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到 DB ，DB 可能会压力过重。</p><p>  当发生大量的缓存穿透，例如对某个失效的缓存的高并发访问也会造成缓存雪崩。</p></li><li><p><strong>解决方法</strong></p><p>  缓存失效时的雪崩效应对底层系统的冲击非常可怕。遗憾的是，这个问题目前并没有很完美的解决方案。</p><p>  一种常用的方法是，用<strong>加锁或者队列的方式保证缓存的单线程（进程）写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。</p><p>  另一种方法是<strong>合理设计的缓存过期时间，将数据失效时间均匀地分布在时间轴上</strong>，一定程度上能够避免缓存同时失效带来的雪崩效应。例如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><h3 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h3><ul><li><p><strong>问题描述</strong></p><p>  有时候如果<strong>网站并发访问高</strong>，一个缓存如果失效，可能出现多个进程同时查询 DB，同时设置缓存的情况，如果并发确实很大，这也可能造成 DB 压力过大，还有缓存频繁更新的问题。</p></li><li><p><strong>解决方法</strong></p><p>  常用的解决方法是对<strong>缓存查询加锁</strong>，如果 KEY 不存在，就加锁，然后查 DB 后写入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入 DB 查询。</p><p>  这种解决方式会造成部分请求等待。</p></li></ul><h2 id="缓存算法-1"><a href="#缓存算法-1" class="headerlink" title="缓存算法"></a>缓存算法</h2><p>缓存算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。</p><p>缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。常用的淘汰算法有下面几种：</p><ul><li><strong>FIFO：First In First Out</strong>，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。</li><li><strong>LRU：Least Recently Used</strong>，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。</li><li><strong>LFU：Least Frequently Used</strong>，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。</li><li><p><strong>ARC</strong>自适应缓存替换算法(ARC)：</p><p>  在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。</p></li><li><strong>MRU：Most Recently Used</strong>，最近最常使用算法，和 LRU 正好相反。它会移除最近最多被使用的对象。</li></ul><p><strong>LRU类算法对比</strong><br>由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析</p><table><thead><tr><th>对比点</th><th>对比</th></tr></thead><tbody><tr><td>命中率</td><td>LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td>复杂度</td><td>LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td>代价</td><td>LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr></tbody></table><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><ul><li><p><strong>实现</strong>，最常见的实现是使用一个<strong>链表保存缓存数</strong>据，详细算法实现如下：</p><ul><li>新数据插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ul></li><li><p><strong>命中率</strong>：当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p></li><li><p><strong>复杂度</strong>：实现简单。</p></li><li><p><strong>代价</strong>：命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。</p></li></ul><blockquote><p>MySQL的InnoDB引擎设置有索引及数据缓存池，其中用到的LRU算法来维持缓存的命中率</p></blockquote><h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><ul><li><p><strong>原理</strong></p><p>  LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p></li><li><p><strong>实现</strong></p><p>  相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：</p><ul><li>数据第一次被访问，加入到访问历史列表；</li><li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li><li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li><li>缓存数据队列中被再次访问后，重新排序；</li><li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li></ul></li></ul><p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p><ul><li><p><strong>命中率</strong>：LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。</p></li><li><p><strong>复杂度</strong>：LRU-K队列是一个优先级队列，算法复杂度和代价比较高。</p></li><li><p><strong>代价</strong>：由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。</p></li></ul><p>LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。</p><p><strong>参考</strong>:</p><ol><li><a href="http://twei.site/2017/07/15/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存那些事–什么是缓存，为什么要用缓存</a></li><li><a href="http://twei.site/2017/07/15/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E7%BC%93%E5%AD%98%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="external">缓存那些事–缓存中常见的问题</a></li><li><a href="http://twei.site/2017/08/02/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存那些事–分布式缓存</a></li><li><a href="http://blog.jobbole.com/30940/" target="_blank" rel="external">缓存、缓存算法和缓存框架简介</a></li><li><a href="http://flychao88.iteye.com/blog/1977653" target="_blank" rel="external">缓存淘汰算法–LRU算法</a></li><li><a href="http://twei.site/2017/07/15/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5/" target="_blank" rel="external">缓存那些事–常用的缓存失效策略</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在狂补优化方面的知识，缓存也是优化的一大方向。之前关于缓存只是知道它的功能，再多不知道了，这里整理缓存相关的知识，算是优化入门吧。&lt;/p&gt;
&lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="优化，PHP" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%EF%BC%8CPHP/"/>
    
  </entry>
  
  <entry>
    <title>互联网应届生四项职场生存技能</title>
    <link href="http://yoursite.com/2018/07/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%9B%9B%E9%A1%B9%E8%81%8C%E5%9C%BA%E7%94%9F%E5%AD%98%E6%8A%80%E8%83%BD/"/>
    <id>http://yoursite.com/2018/07/11/互联网应届生四项职场生存技能/</id>
    <published>2018-07-11T08:08:38.000Z</published>
    <updated>2018-08-20T03:48:13.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="职场能力一：沟通力"><a href="#职场能力一：沟通力" class="headerlink" title="职场能力一：沟通力"></a>职场能力一：沟通力</h2><p>沟通力是职场最重要也是最基础的一项能力。</p><p>进入职场后，无论从事什么岗位都必然要用到沟通力这个能力项。沟通力有一个很重要的基石，就是尊重对方的时间。每一次沟通，双方其实都要投入很多时间和精力。只有懂得尊重对方的时间，才能更好地去打磨自己的沟通力。想要提升沟通力，有三个方法：</p><h3 id="“BMW”沟通法"><a href="#“BMW”沟通法" class="headerlink" title="“BMW”沟通法"></a>“BMW”沟通法</h3><p>背景说明（Background）即所说事情的背景是什么；<br>关键信息（Message）即所沟通事情关键点是什么；<br>事情（What）即需要我去做什么。</p><p>比如说，去年有个合作伙伴找到我，说他的域名被微信封了，希望我协调一下，尽快解封。本来很简单的一件事情，但是他跟我在微信上前前后后聊了四五页，聊了大概十多分钟我才搞清楚他的需求是什么。</p><p>要是运用“BMW”沟通法，就可以把事情陈述得很清楚，避免挤牙膏式的沟通，问题也可以得到高效解决。</p><p>例：<br>B: “我们的域名XXXX被微信封了，希望你能帮忙协调一下”。<br>M：“因为我们域名有漏洞，被他人恶意注入，导致被封。但我们已经修复漏洞并清除恶意内容，也提交了在线申诉，单号是XXXX”。<br>W:“由于正常审核时间可能需要3天，而我们明天有一个大活动发布，物料已经印制出去了，希望你能帮忙协调加快审核”。</p><h3 id="情绪管理四步法"><a href="#情绪管理四步法" class="headerlink" title="情绪管理四步法"></a>情绪管理四步法</h3><p>人皆有情绪，在职场里，情绪的出现很正常，但情绪往往会影响沟通效率。如何调整自己在职场里面的情绪呢？当我们有情绪的时候，要先处理情绪，再处理事情。法则是识别情绪、接受情绪、理解情绪和调整情绪。</p><p>可以告诉自己“噢，我有情绪了，这很正常，但是吵架解决不了问题。我换个说法再试试。”</p><p>说出来后，你的情绪基本上已消解下去，你可以调回正常频道，以一个正常心态再跟对方进行沟通。</p><h3 id="白纸黑字法"><a href="#白纸黑字法" class="headerlink" title="白纸黑字法"></a>白纸黑字法</h3><p>大家当面沟通的时候，思维一开始是比较分散的，然后再慢慢收敛，最后才达成共识。但是当大家回到座位后，很有可能会记岔。比较好的工作方式，就是每次沟通完需求后，把它形成一个文档，再把文档丢到沟通群或者给对应的同事。</p><p>“ 沟通力小结：多吃点亏，多打磨 ”</p><h2 id="职场能力二：理解力"><a href="#职场能力二：理解力" class="headerlink" title="职场能力二：理解力"></a>职场能力二：理解力</h2><p>在职场上，当你与同事沟通时你觉得完全不费劲，不需要很详细地跟他解释，他能够立马举一反三的时候，就是理解力的一种体现。理解力其实是一种思维方式的建设过程，在职场上想要提升理解力可以从三方面入手：</p><h3 id="建立项目思维"><a href="#建立项目思维" class="headerlink" title="建立项目思维"></a>建立项目思维</h3><p>首先，项目化管理工作内容。锻炼自己的项目思维，第一个要做的事情是先把文件夹管理好。通过把文件夹分门别类，把工作梳理清楚，工作有哪几块，每一块下面又有哪些环节，每一个环节下面又有一些什么关键点。</p><p>其次，项目化管理工作时间。把工作拆分成一个个小项目，然后通过三种不同的色块去体现项目的进度。在色块中间，再通过一些文字去记录这个时间点里面一些重要信息和关键信息。通过这个项目表，可以帮助管理自己所负责的项目，也能够去把握这些项目的时间跟节奏。</p><p>最后，学会结构化思考，即运用TIPS模型。第一是目标（Target），即达成的结果；第二是现状（Reality），即现有的资源/条件；第三个是计划（Plan），即要拿出2-3套方案；第四是步骤（Step），即行动分解。tips思考方式在老板布置任务，尤其是临时布置任务给你的时候特别好用。</p><h3 id="“点线面”角度"><a href="#“点线面”角度" class="headerlink" title="“点线面”角度"></a>“点线面”角度</h3><p>当大家在工作上做一个需求点的时候，不要只看到这个点，而是要去想这个点背后可能还有一根线，这个线上还有一些角色，这个面上可能还有更多的角色，他们互相是什么关系。当你清楚了这些信息后，才能够更好去理解，我应该怎么去做好这个需求？我怎么去做好这个服务？我怎么去做好这个产品？</p><p>第一个关键点是你要站在一个更高的角度看这个事情；<br>第二个关键点是你需要去获取一些更多有价值的信息，通过这些信息能够帮助你去梳理清楚这个需求点背后的逻辑是怎么样的。</p><h3 id="保持思考"><a href="#保持思考" class="headerlink" title="保持思考"></a>保持思考</h3><p>在日常生活中保持思考的敏感度，这样才能够做到，看到产品、用户、数据时会去想一想它背后的逻辑是什么。</p><p>例：有天中午我吃完饭路过了公司园区内新开的健身房，这时候我就在思考，这个店大概60平方，一个月租金大概要1万2。并且它采用APP预约方式，到店后再通过扫码进去，不提供教练也不提供额外服务，店里面有一个看店的人员。假设这个看店的人员的工资是5千块，这家店不算器械的折旧，它一个月的运营成本大概也要到1万8到2万块钱。而它的收费标准是48块钱1.5小时一个人。最后我得出的结论就是，它这个生意应该不太好做，估计开不久。果然，大概七八个月，这家店就倒闭了。</p><p>就这样，像我看到一个健身房，我会去想它背后经营的逻辑是什么样的。一旦建立了这种保持思考的惯性，一定程度上就能够帮助大家快速提升理解力。</p><p>“ 理解力小结: 在日常中多思考。”</p><h2 id="职场能力三：连接力"><a href="#职场能力三：连接力" class="headerlink" title="职场能力三：连接力"></a>职场能力三：连接力</h2><p>人脉在职场上起着非常重要的作用，连接力就是让自己成为信息的中心，建立自己的人脉关系网络。建立连接力可从三方面着手：</p><h3 id="给自己贴标签"><a href="#给自己贴标签" class="headerlink" title="给自己贴标签"></a>给自己贴标签</h3><p>一是业务标签，即你的工作范围是什么？加强自己业务标签的方式并不复杂，比如在部门或其他沟通群里，有跟你业务相关的问题，别人抛出问题的时候，你第一时间跳出来说我来处理一下。慢慢地，大家心里就会建立一个感知，知道你是负责哪一个业务的，知道你是谁。</p><p>二是能力标签，即你这个人是怎么样的？你的能力项在哪里？能力标签诸如“做事靠谱”、“人脉广”、“拓展能力强”、“理解能力强”、“学习力强”，贴这些标签是说我希望在别人印象中可以留下这样的印象，我会这样去规范自己，希望自己能够符合这些标签，让自己做事更靠谱。贴完了之后就想办法在自己的工作过程中往这个方向去努力，把这个标签在你的日常工作中不断地去强化。</p><h3 id="建立接触点"><a href="#建立接触点" class="headerlink" title="建立接触点"></a>建立接触点</h3><p>去建立一些接触点，通过这些触点能够更好地帮你去连接人。建立了接触点，建立了人脉之后，会更好地帮助你跨部门沟通、跨团队沟通。尤其是在类似腾讯这样的大公司里，产品特别多，环节也特别多。如果你在做一个需求的时候，你提前知道这个需求相关联的有哪些人，你就可以提前跟他们做好沟通。</p><p>“ 连接力小结：建立自己的人际脉络”</p><h2 id="职场能力四：行动力"><a href="#职场能力四：行动力" class="headerlink" title="职场能力四：行动力"></a>职场能力四：行动力</h2><p>行动力，就是一个人解决问题的能力。行动力是最终衡量大家在职场是否有好的输出的关键一环。建立自己的行动力，在一定程度上就是培养自己解决问题的能力。提升行动力可从三方面入手：</p><h3 id="勇于承担"><a href="#勇于承担" class="headerlink" title="勇于承担"></a>勇于承担</h3><p>刚进入职场的新同学很容易会陷入一个打杂的过程，其实很正常，因为你刚进入职场，你对整个业务模块还不太清楚，所以很有可能你要负责琐碎的事情。你可以换一个角度去思考，打杂其实也会有很多的价值在里面，就看你敢不敢去承担，看你怎么去思考这个问题。</p><h3 id="多试几条路"><a href="#多试几条路" class="headerlink" title="多试几条路"></a>多试几条路</h3><p>举个简单的例子，老板让你定个会议室。你查阅了本层楼的会议室，发现都被订了，放在你面前的至少还有三个路径是可以尝试的，比如说看看其他楼层有没有会议室，看看附近的大厦有没有会议室。还可以看看已经被预定的会议室，能否协调把时间腾出来。一旦建立了这样一个思考方式，去多找几条路，那么解决问题的概率就会提升，也在一定程度上提升了行动力。</p><h3 id="让领导做选择题"><a href="#让领导做选择题" class="headerlink" title="让领导做选择题"></a>让领导做选择题</h3><p>跟领导沟通的时候，千万不要用“怎么办”去做结尾，而是采用“背景方案+建议”的组合拳。比如说你做一个需求，但开发资源已经被其他紧要项目占用了。这个时候你不要跟老板说，因为没有开发资源，这个需求做不了，那怎么办呢？你可以这样说，现在开发资源被另一个项目占了，我们是否可以把需求砍得再细一些，先做关键的最重要的A需求，其他需求延后一些。在跟老板沟通的时候，尽量给他做选择题，给他一些建议，给他一些方案，最后问他选这个方案好不好，而不是问他这个事情到底应该怎么办。</p><p>提升职场修炼的四个力可以归结为一个字——磨：在日常工作中，不断打磨自己；在不断打磨的过程中，在脑海里形成一个思考的框架、思路和做事方法。一旦这个思考的思路和方法形成之后，整个职场力就会随之提升。</p><p>参考：</p><ol><li><p><a href="https://mp.weixin.qq.com/s/tuNdVzaJ9xwzwcF3seT5MA" target="_blank" rel="external">腾讯内部：有这4个技能的应届生，我们要定了！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/YOOd3ci0D4WEhOKTVI-LlA?scene=25#wechat_redirect" target="_blank" rel="external">[鹅厂@你]你有一条来自鹅厂内部《职场修炼》课程讲师的消息未读</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;职场能力一：沟通力&quot;&gt;&lt;a href=&quot;#职场能力一：沟通力&quot; class=&quot;headerlink&quot; title=&quot;职场能力一：沟通力&quot;&gt;&lt;/a&gt;职场能力一：沟通力&lt;/h2&gt;&lt;p&gt;沟通力是职场最重要也是最基础的一项能力。&lt;/p&gt;
&lt;p&gt;进入职场后，无论从事什么岗位
      
    
    </summary>
    
      <category term="知识扩展" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95/"/>
    
    
      <category term="职场技能" scheme="http://yoursite.com/tags/%E8%81%8C%E5%9C%BA%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>PHP操作MySQL数据库（连接、增删改操作）</title>
    <link href="http://yoursite.com/2018/07/11/PHP%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/11/PHP操作MySQL数据库（连接、增删改操作）/</id>
    <published>2018-07-11T08:08:38.000Z</published>
    <updated>2018-07-11T11:06:41.245Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 是跟 PHP 配套使用的最流行的开源数据库系统，我们知道MySQL是PHP的最佳搭档，下面是系统的总结PHP与MySQL联合使用的方法。主要是使用MySQL扩展，下面就通过归纳总结来提升。</p><h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a><a href="http://www.mysql.com" target="_blank" rel="external">MySQL</a>概述</h2><p>MySQL 是一种在 Web 上使用的数据库系统。</p><p>MySQL 是一种在服务器上运行的数据库系统。</p><p>MySQL 不管在小型还是大型应用程序中，都是理想的选择。</p><p>MySQL 是非常快速，可靠，且易于使用的。</p><p>MySQL 支持标准的 SQL。</p><p>MySQL 在一些平台上编译。</p><p>MySQL 是免费下载使用的。</p><p>MySQL 是由 Oracle 公司开发、发布和支持的。</p><p>MySQL 是以公司创始人 Monty Widenius’s daughter: My 命名的。</p><p>PHP 与 MySQL 结合是跨平台的。（您可以在 Windows 上开发，在 Unix 平台上应用。）</p><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>PHP 使用 MySQL 数据库前，需要先将它们连接。</p><ul><li><p><strong>PHP连接MySQL的四种方式</strong>：</p><ul><li><strong>MySQL 扩展</strong></li><li><strong>MySQLi 扩展</strong> (“i” 意为 improved)</li><li><strong>PDO</strong> (PHP Data Objects)</li><li><p><strong>PHP 使用 ODBC 连接数据库</strong></p><blockquote><p>PHP 5 及以上版本推荐使用MySQLi 扩展和PDO。在 PHP 早起版本中我们使用 MySQL 扩展。但该扩展在 2012 年开始不建议使用。</p></blockquote><p>MySQLi | PDO<br>—|—<br>只针对 MySQL 数据库 | 应用在 12 种不同数据库中<br>面向对象(还提供API接口) | 面向对象<br>支持预处理语句 | 支持预处理语句</p><blockquote><p>预处理语句可以防止<strong>SQL注入</strong>，对于web项目的安全性是非常重要的。</p></blockquote></li></ul></li><li><p><strong>PHP的MySQL扩展(优缺点)</strong></p><p>  设计开发允许PHP应用与MySQL数据库交互的早期扩展。mysql扩展提供了一个面向过程 的接口；</p><p>  并且是针对MySQL4.1.3或更早版本设计的。因此，这个扩展虽然可以与MySQL4.1.3或更新的数据库服务端 进行交互，但并不支持后期MySQL服务端提供的一些特性。</p></li><li><p><strong>PHP的mysqli扩展</strong></p><p>  mysqli扩展，我们有时称之为MySQL增强扩展，可以用于使用 MySQL4.1.3或更新版本中新的高级特性；</p><p>  mysqli扩展在PHP 5及以后版本中包含；</p><p>  mysqli扩展有一系列的优势，相对于mysql扩展的提升主要有：面向对象接口、 prepared语句支持、多语句执行支持、事务支持、增强的调试能力、嵌入式服务支持。</p></li><li><p><strong>PHP数据对象(PDO)</strong></p><p>  PHP数据对象，是PHP应用中的一个数据库抽象层规范。PDO提供了一个统一的API接口可以，使得你的PHP应用不去关心具体要 连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器。</p></li><li><p><a href="https://www.w3cschool.cn/php/php-db-odbc.html" target="_blank" rel="external"><strong>PHP 使用 ODBC 连接数据库</strong></a></p><p>  ODBC 是一种应用程序编程接口（Application Programming Interface，API），使我们有能力连接到某个数据源（比如一个 MS Access 数据库）。</p><p>  （1）<strong>创建 ODBC 连接</strong></p><p>  通过一个 ODBC 连接，您可以连接到您的网络中的任何计算机上的任何数据库，只要 ODBC 连接是可用的。</p><p>  （2）<strong>连接到 ODBC</strong></p><p>  <code>odbc_connect()</code> 函数用于连接到 ODBC 数据源。该函数有四个参数：数据源名、用户名、密码以及可选的指针类型。</p><p>  <code>odbc_exec()</code> 函数用于执行 SQL 语句。</p><p>  （3）<strong>取回记录</strong></p><p>  <code>odbc_fetch_row()</code> 函数用于从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。该函数有两个参数：ODBC 结果标识符和可选的行号，如：<code>odbc_fetch_row($rs)</code>。</p><p>  （4）<strong>从记录中取回字段</strong></p><p>  <code>odbc_result()</code> 函数用于从记录中读取字段。该函数有两个参数：ODBC 结果标识符和字段编号或名称。<code>$compname=odbc_result($rs,1);</code>从记录中返回第一个字段的值；<code>compname=odbc_result($rs,&quot;CompanyName&quot;);</code>返回名为 “CompanyName” 的字段的值。</p><p>  （5）<strong>关闭 ODBC 连接</strong></p><p>  <code>odbc_close()</code> 函数用于关闭 ODBC 连接，<code>odbc_close($conn);</code>。</p></li></ul><h3 id="MySQL扩展连接数据库"><a href="#MySQL扩展连接数据库" class="headerlink" title="MySQL扩展连接数据库"></a>MySQL扩展连接数据库</h3><ul><li><p><a href="http://www.w3school.com.cn/php/func_mysql_connect.asp" target="_blank" rel="external"><code>mysql_connect()</code></a> 函数打开非持久的 MySQL 连接</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  &lt;?php</div><div class="line">$host = &quot;localhost&quot;;     //MySQL服务器名称</div><div class="line">  $user = &quot;root&quot;;          //用户名</div><div class="line">  $password = &quot;123456&quot;;      //访问密码</div><div class="line">  $db_name = &quot;dsplab&quot;;         //数据库名称</div><div class="line">  $conn = mysql_connect($host,$user,$password) or </div><div class="line">  die (&quot;连接到MySQL服务器失败。&quot;.mysql_error());   //返回错误信息</div><div class="line">  mysql_select_db($db_name,$conn)  or</div><div class="line">  die (&quot;连接数据库失败。&quot;.mysql_error());   //返回错误信息</div><div class="line"> </div><div class="line"> // 设置数据格式，解决中文乱码</div><div class="line"> mysql_query(&apos;set names utf8&apos;);</div><div class="line"> </div><div class="line"> mysql_close($con);  // 关闭连接</div><div class="line">  ?&gt;</div></pre></td></tr></table></figure><blockquote><p><code>mysql_close()</code>关闭连接，通常不必要，因为PHP在脚本终止时自动关闭打开的连接；</p></blockquote></li><li><p><a href="http://www.w3school.com.cn/php/func_mysql_pconnect.asp" target="_blank" rel="external"><code>mysql_pconnect()</code></a> 函数打开一个到 MySQL 服务器的持久连接</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $con = mysql_pconnect(&quot;localhost&quot;,&quot;mysql_user&quot;,&quot;mysql_pwd&quot;);</div><div class="line">    if (!$con)</div><div class="line">      &#123;</div><div class="line">      die(&apos;Could not connect: &apos; . mysql_error());</div><div class="line">      &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></li></ul><pre><code>&gt; 不能用`mysql_close()`关闭</code></pre><ul><li><p><strong>区别</strong>。<code>mysql_pconnect()</code> 和 <code>mysql_connect()</code> 非常相似，但有两个主要区别：</p><p>  当连接的时候本函数将先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的（持久）连接，如果找到，则返回此连接标识而不打开新连接。<br>  其次，当脚本执行完毕后到 SQL 服务器的连接不会被关闭，此连接将保持打开以备以后使用（<code>mysql_close()</code> 不会关闭由 <code>mysql_pconnect()</code> 建立的连接）。</p></li></ul><h3 id="MySQLi扩展连接数据库"><a href="#MySQLi扩展连接数据库" class="headerlink" title="MySQLi扩展连接数据库"></a>MySQLi扩展连接数据库</h3><ul><li><p>MySQLi - 面向对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">$servername = &quot;localhost&quot;; </div><div class="line">$username = &quot;username&quot;; </div><div class="line">$password = &quot;password&quot;; </div><div class="line"></div><div class="line">// 创建连接 </div><div class="line">$conn = new mysqli($servername, $username, $password); </div><div class="line"></div><div class="line">// 检测连接 </div><div class="line">if ($conn-&gt;connect_error) &#123; </div><div class="line">    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error); </div><div class="line">&#125; </div><div class="line">echo &quot;Connected successfully&quot;; </div><div class="line"></div><div class="line">// 关闭连接</div><div class="line">$conn-&gt;close();</div><div class="line">?&gt;</div></pre></td></tr></table></figure></li><li><p>MySQLi - 面向过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">$servername = &quot;localhost&quot;; </div><div class="line">$username = &quot;username&quot;; </div><div class="line">$password = &quot;password&quot;; </div><div class="line"></div><div class="line">// 创建连接 </div><div class="line">$conn = mysqli_connect($servername, $username, $password); </div><div class="line"></div><div class="line">// 检测连接 </div><div class="line">if (!$conn) &#123; </div><div class="line">    die(&quot;Connection failed: &quot; . mysqli_connect_error()); </div><div class="line">&#125; </div><div class="line">echo &quot;Connected successfully&quot;; </div><div class="line"></div><div class="line">// 关闭连接</div><div class="line">mysqli_close($conn);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></li></ul><h3 id="PDO连接数据库"><a href="#PDO连接数据库" class="headerlink" title="PDO连接数据库"></a>PDO连接数据库</h3><ul><li><p>PDO</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">$servername = &quot;localhost&quot;; </div><div class="line">$username = &quot;username&quot;; </div><div class="line">$password = &quot;password&quot;; </div><div class="line"></div><div class="line">try &#123; </div><div class="line">    $conn = new PDO(&quot;mysql:host=$servername;dbname=myDB&quot;, $username, $password); </div><div class="line">    echo &quot;Connected successfully&quot;; </div><div class="line">&#125; </div><div class="line">catch(PDOException $e) &#123; </div><div class="line">    echo $e-&gt;getMessage(); </div><div class="line">&#125; </div><div class="line">    </div><div class="line">// 关闭连接    </div><div class="line">$conn = null;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><blockquote><p>注意在以上 PDO 实例中我们已经指定了数据库 (myDB)。PDO 在连接过程需要设置数据库名。如果没有指定，则会抛出异常。</p></blockquote></li></ul><h2 id="增删改（创建数据库、数据表，增删改操作-）"><a href="#增删改（创建数据库、数据表，增删改操作-）" class="headerlink" title="增删改（创建数据库、数据表，增删改操作 ）"></a>增删改（创建数据库、数据表，增删改操作 ）</h2><p>这些操作，增删改三种操作除了返回操作成功与否的信息，没有其他结果返回，操作基本相同，只需要记住增删改操作的SQL语句即可。将SQL语句用双引号包含，赋值给变量$sql，之后用PHP代码操作：</p><ul><li><p>面向对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ($conn-&gt;query($sql) === TRUE) &#123;</div><div class="line">    echo &quot;操作成功&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;存在错误: &quot; . $conn-&gt;error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>面向过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (mysqli_query($conn, $sql)) &#123;</div><div class="line">    echo &quot;操作成功&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;存在错误: &quot; . mysqli_error($conn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>PHP 中 SQL 查询语句语法规则</strong></p><ul><li>PHP 中 SQL 查询语句必须使用引号</li><li>在 SQL 查询语句中的字符串值必须加引号</li><li>数值的值不需要引号</li><li>NULL 值不需要引号</li></ul></li></ul><h3 id="创建数据库、数据表"><a href="#创建数据库、数据表" class="headerlink" title="创建数据库、数据表"></a><strong>创建数据库、数据表</strong></h3><ul><li><p>面向对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 创建数据库</div><div class="line">$sql = &quot;CREATE DATABASE myDB&quot;;</div><div class="line">if ($conn-&gt;query($sql) === TRUE) &#123;</div><div class="line">    echo &quot;Database created successfully&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;Error creating database: &quot; . $conn-&gt;error;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 创建数据表</div><div class="line">$sql = &quot;CREATE TABLE MyGuests (</div><div class="line">id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, </div><div class="line">firstname VARCHAR(30) NOT NULL,</div><div class="line">lastname VARCHAR(30) NOT NULL,</div><div class="line">email VARCHAR(50),</div><div class="line">reg_date TIMESTAMP</div><div class="line">)&quot;;</div><div class="line"></div><div class="line">if ($conn-&gt;query($sql) === TRUE) &#123;</div><div class="line">    echo &quot;Table MyGuests created successfully&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;Error creating table: &quot; . $conn-&gt;error;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>创建一个名为 “MyGuests” 的表，有 5 个列： “id”, “firstname”, “lastname”, “email” 和 “reg_date”</p></blockquote></li><li><p>面向过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建数据库，$sql语句同上</div><div class="line">if (mysqli_query($conn, $sql)) &#123;</div><div class="line">    echo &quot;Database created successfully&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;Error creating database: &quot; . mysqli_error($conn);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 创建数据表，$sql语句同上</div><div class="line">if (mysqli_query($conn, $sql)) &#123;</div><div class="line">    echo &quot;Table MyGuests created successfully&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    echo &quot;Error creating table: &quot; . mysqli_error($conn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><ul><li><p>INSERT INTO 语句通常用于向 MySQL 表添加新的记录：    </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name (column1, column2, column3,...) VALUES (value1, value2, value3,...)</div></pre></td></tr></table></figure><blockquote><p>注意： 如果列设置 AUTO_INCREMENT (如 “id” 列) 或 TIMESTAMP (如 “reg_date” 列),，我们就不需要在 SQL 查询语句中指定值； MySQL 会自动为该列添加值。</p></blockquote></li><li><p>插入一条记录，采用下列SQL语句</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 插入一条记录</div><div class="line">// 方法一，按照表字段一一对应添加,缺一不可</div><div class="line">$sql = &quot;INSERT INTO table_name VALUES (&apos;value1&apos;, &apos;value2&apos;, ...)&quot;; </div><div class="line"></div><div class="line">// 方法二，按指定的字段添加数据</div><div class="line">$sql = &quot;INSERT INTO table_name (column1, column2, ...) </div><div class="line">VALUES (&apos;value1&apos;, &apos;value2&apos;, ...)&quot;;</div></pre></td></tr></table></figure></li><li><p>插入多条记录，采用下列SQL语句</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 插入多条记录</div><div class="line">$sql = &quot;INSERT INTO </div><div class="line">MyGuests (firstname, lastname, email) VALUES (&apos;John&apos;, &apos;Doe&apos;, &apos;john@example.com&apos;);&quot;;</div><div class="line"></div><div class="line">$sql .= &quot;INSERT INTO </div><div class="line">MyGuests (firstname, lastname, email) VALUES (&apos;Mary&apos;, &apos;Moe&apos;, &apos;mary@example.com&apos;);&quot;;</div><div class="line"></div><div class="line">$sql .= &quot;INSERT INTO </div><div class="line">MyGuests (firstname, lastname, email) VALUES (&apos;Julie&apos;, &apos;Dooley&apos;, &apos;julie@example.com&apos;)&quot;;</div></pre></td></tr></table></figure></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p>删除数据库、数据表、记录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   // 删除数据库</div><div class="line">   $sql = &quot;drop database if exists &lt;database_name&gt;&quot;</div><div class="line">   </div><div class="line">   // 删除数据表</div><div class="line">   $sql = &quot;drop tabel if exists &lt;table_name&gt;&quot;</div><div class="line">   </div><div class="line">   // 删除记录</div><div class="line">$sql = &quot;DELETE FROM table_name&quot;// 删除所有的数据</div><div class="line">// or</div><div class="line">   $sql = &quot;DELETE FROM table_name WHERE some_column = some_value&quot;// 删除特定的数据</div></pre></td></tr></table></figure></li></ul><h3 id="改（修改记录）"><a href="#改（修改记录）" class="headerlink" title="改（修改记录）"></a>改（修改记录）</h3><ul><li><p>修改记录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 修改表名</div><div class="line">$sql = &quot;alter table old_table_neme rename new_table_neme&quot;</div><div class="line"></div><div class="line">// 修改记录</div><div class="line">   $sql = &quot;UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value&quot;</div></pre></td></tr></table></figure></li></ul><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><p>查询记录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 读取所有的数据</div><div class="line">$sql = &quot;SELECT id, column1, column2 FROM table_name&quot;;</div><div class="line"></div><div class="line">// where子句</div><div class="line">$sql = &quot;SELECT field FROM table_name WHERE column_name operator value&quot;;</div><div class="line">$result = mysqli_query($con,&quot;SELECT * FROM Persons WHERE FirstName=&apos;Peter&apos;&quot;);// 示例</div><div class="line"></div><div class="line">// order by</div><div class="line">   $sql = &quot;UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value&quot;</div></pre></td></tr></table></figure></li></ul><h2 id="扩展——预处理语句及绑定参数"><a href="#扩展——预处理语句及绑定参数" class="headerlink" title="扩展——预处理语句及绑定参数"></a>扩展——<a href="https://www.w3cschool.cn/php/php-mysql-prepared-statements.html" target="_blank" rel="external">预处理语句及绑定参数</a></h2><p>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><ul><li><p><strong>预处理语句的工作原理如下</strong>：</p><ul><li><strong>预处理</strong>：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：<code>INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)</code></li><li><strong>数据库解析，编译</strong>，对SQL语句模板执行查询优化，并存储结果不输出</li><li><strong>执行</strong>：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。</li></ul></li><li><p><strong>相比于直接执行SQL语句，预处理语句有两个主要优点</strong>：</p><ul><li>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）</li><li>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句</li><li>预处理语句针对SQL注入是非常有用的，因为 参数值发送后使用不同的协议，保证了数据的合法性。</li></ul></li></ul><ul><li><p><strong>MySQLi预处理</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// prepare and bind</div><div class="line">// 在 SQL 语句中，我们使用了问号 (?)，在此我们可以将问号替换为整型，字符串，双精度浮点型和布尔值。</div><div class="line">// 该函数绑定了 SQL 的参数(每个参数都需要指定类型)，且告诉数据库参数的值。 &quot;sss&quot; 参数列处理其余参数的数据类型。s 字符告诉数据库该参数为字符串。</div><div class="line">$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);</div><div class="line">$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);</div><div class="line"></div><div class="line">// 设置参数并执行</div><div class="line">$firstname = &quot;John&quot;;</div><div class="line">$lastname = &quot;Doe&quot;;</div><div class="line">$email = &quot;john@example.com&quot;;</div><div class="line">$stmt-&gt;execute();</div><div class="line"></div><div class="line">$firstname = &quot;Mary&quot;;</div><div class="line">$lastname = &quot;Moe&quot;;</div><div class="line">$email = &quot;mary@example.com&quot;;</div><div class="line">$stmt-&gt;execute();</div><div class="line"></div><div class="line">$firstname = &quot;Julie&quot;;</div><div class="line">$lastname = &quot;Dooley&quot;;</div><div class="line">$email = &quot;julie@example.com&quot;;</div><div class="line">$stmt-&gt;execute();</div><div class="line"></div><div class="line">echo &quot;New records created successfully&quot;;</div><div class="line"></div><div class="line">$stmt-&gt;close();</div><div class="line">$conn-&gt;close();</div></pre></td></tr></table></figure><blockquote><p><strong>绑定参数（bind_param）有以下四种类型</strong>:</p><ul><li>i - integer（整型）</li><li>d - double（双精度浮点型）</li><li>s - string（字符串）</li><li>b - BLOB（布尔值）</li></ul><p>如果你想插入其他数据（用户输入），对数据的验证是非常重要的。</p></blockquote></li></ul><p>关于查询的返回结果，详见博客<a href="http://dingby.site/2018/06/19/php%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" target="_blank" rel="external">《php数据库中数据查询》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 是跟 PHP 配套使用的最流行的开源数据库系统，我们知道MySQL是PHP的最佳搭档，下面是系统的总结PHP与MySQL联合使用的方法。主要是使用MySQL扩展，下面就通过归纳总结来提升。&lt;/p&gt;
&lt;h2 id=&quot;MySQL概述&quot;&gt;&lt;a href=&quot;#MySQL
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP简单功能的实现</title>
    <link href="http://yoursite.com/2018/07/10/PHP%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/07/10/PHP简单功能的实现/</id>
    <published>2018-07-10T13:19:38.000Z</published>
    <updated>2018-08-20T03:58:07.731Z</updated>
    
    <content type="html"><![CDATA[<h4 id="检查一个变量是否为空"><a href="#检查一个变量是否为空" class="headerlink" title="检查一个变量是否为空"></a>检查一个变量是否为空</h4><ul><li>empty功能<ul><li>返回值：</li><li>若变量不存在则返回 TRUE</li><li>若变量存在且其值为””、0、”0”、NULL、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 TURE</li><li>若变量存在且值不为””、0、”0”、NULL、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 FALSE</li></ul></li></ul><blockquote><p>函数支持版本：(PHP 4, PHP 5, PHP 7</p></blockquote><h4 id="PHP提取字符串中的数字"><a href="#PHP提取字符串中的数字" class="headerlink" title="PHP提取字符串中的数字"></a>PHP提取字符串中的数字</h4><ul><li><p>使用正则表达式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function findNum($str=&apos;&apos;)&#123;</div><div class="line">     $str=trim($str);</div><div class="line">     if(empty($str))&#123;return &apos;&apos;;&#125;      </div><div class="line">     $reg=&apos;/(\d&#123;3&#125;(\.\d+)?)/is&apos;;//匹配数字的正则表达式</div><div class="line">     preg_match_all($reg,$str,$result);</div><div class="line">     if(is_array($result)&amp;&amp;!empty($result)&amp;&amp;!empty($result[1])&amp;&amp;!empty($result[1][0]))&#123;</div><div class="line">         return $result[1][0];</div><div class="line">     &#125;  </div><div class="line">     return &apos;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>in_array方法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function findNum($str=&apos;&apos;)&#123;</div><div class="line">$str=trim($str);</div><div class="line">      if(empty($str))&#123;return &apos;&apos;;&#125;</div><div class="line">      $temp=array(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;0&apos;);</div><div class="line"> $result=&apos;&apos;;</div><div class="line"> for($i=0;$i&lt;strlen($str);$i++)&#123;</div><div class="line">            if(in_array($str[$i],$temp))&#123;</div><div class="line">                 $result.=$str[$i];</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">return $result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>is_numeric函数：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function findNum($str=&apos;&apos;)&#123;</div><div class="line">     $str=trim($str);</div><div class="line">     if(empty($str))&#123;return &apos;&apos;;&#125;</div><div class="line">     $result=&apos;&apos;;</div><div class="line">     for($i=0;$i&lt;strlen($str);$i++)&#123;</div><div class="line">          if(is_numeric($str[$i]))&#123;</div><div class="line">                $result.=$str[$i];</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     return $result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h4 id="PHP操作数组"><a href="#PHP操作数组" class="headerlink" title="PHP操作数组"></a>PHP操作数组</h4><ul><li><p>创建空数组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x = [];</div><div class="line">var_dump($x);   // array(0) &#123;&#125;</div></pre></td></tr></table></figure></li><li><p>php 合并数组，且不重复相同的元素</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$a = array(&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;10&quot;,&quot;15&quot;);</div><div class="line">$b = array(&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;6&quot;,&quot;9&quot;);</div><div class="line">$x = array_unique(array_merge($a,$b));</div><div class="line">var_dump($x); </div><div class="line">// 结果：array(&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;10&quot;,&quot;15&quot;,&quot;6&quot;,&quot;9&quot; )</div></pre></td></tr></table></figure></li><li><p>php找到两个数组中相同的元素</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 找出两个数组相同的项</div><div class="line">function getSameArr($a1,$a2)&#123;</div><div class="line">    $alength = count($a1);</div><div class="line">    for ($i=0; $i &lt;$alength ; $i++) &#123;</div><div class="line">        if (in_array($a1[$i],$a2)) &#123;</div><div class="line">            $sameArr[] = $a1[$i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if ($sameArr) &#123;</div><div class="line">        return $sameArr;</div><div class="line">    &#125;else&#123;</div><div class="line">        return array(&quot;0&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h4 id="前端显示若超过字数，后面使用省略号"><a href="#前端显示若超过字数，后面使用省略号" class="headerlink" title="前端显示若超过字数，后面使用省略号"></a>前端显示若超过字数，后面使用省略号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    if (strlen($new[&apos;title&apos;]) &lt; 51 ) &#123;</div><div class="line">         echo $new[&apos;title&apos;];</div><div class="line">    &#125;else&#123;</div><div class="line">         echo mb_substr($new[&apos;title&apos;], 0,17,&apos;utf-8&apos;).&apos;...&apos;;</div><div class="line">    &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h4 id="修改PHP上传文件的大小限制"><a href="#修改PHP上传文件的大小限制" class="headerlink" title="修改PHP上传文件的大小限制"></a>修改PHP上传文件的大小限制</h4><p>使用POST请求提交的数据大小超过了服务器的最大限制数(8388608字节=8MB)会报告如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Warning: POST Content-Length of 625523488 bytes exceeds the limit of 8388608 bytes in Unknown on line 0</div></pre></td></tr></table></figure><p>如果需要的话，可以通过修改PHP的配置文件<code>php.ini</code>中的<code>post_max_size</code>参数的值。</p><p>在PHP的配置文件<code>php.ini</code>中，默认存在如下配置信息(在php.ini中，行首的分号”;”表示当前行是注释，不会生效)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">;脚本解析输入数据(类似 POST 和 GET)允许的最大时间，单位是秒。 它从接收所有数据到开始执行脚本进行测量的。 </div><div class="line">max_input_time = 60</div><div class="line"></div><div class="line">;允许客户端单个POST请求发送的最大数据</div><div class="line">post_max_size = 8M</div><div class="line"></div><div class="line">;是否开启文件上传功能</div><div class="line">file_uploads = On</div><div class="line"></div><div class="line">;文件上传的临时存放目录(如果不指定，使用系统默认的临时目录)</div><div class="line">;upload_tmp_dir =</div><div class="line"></div><div class="line">;允许单个请求上传的最大文件大小</div><div class="line">upload_max_filesize = 2M</div><div class="line"></div><div class="line">;允许单个POST请求同时上传的最大文件数量</div><div class="line">max_file_uploads = 20</div></pre></td></tr></table></figure><h4 id="PHP获取站点根目录"><a href="#PHP获取站点根目录" class="headerlink" title="PHP获取站点根目录"></a>PHP获取站点根目录</h4><ul><li><p>获取文件路径</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">echo __FILE__ ;           // 取得当前文件的绝对地址，结果：D:\www\test.php</div><div class="line">echo dirname(__FILE__);   // 取得当前文件所在的绝对目录，结果：D:\www\</div><div class="line">echo dirname(dirname(__FILE__));      //取得当前文件的上一层目录名，结果：D:\</div><div class="line">?&gt;</div></pre></td></tr></table></figure></li></ul><blockquote><ul><li>魔术常量<code>__FILE__</code>：取得当前文件的路径，这里的路径包含了文件名；</li><li><code>dirname(__FILE__)</code>：返回一层目录；</li><li><code>realpath()</code>函数：返回绝对路径,删除所有符号连接（比如 ‘/./‘, ‘/../‘ 以及多余的 ‘/‘），返回绝对路径名，若失败（如文件不存在），则返回 false。</li></ul></blockquote><ul><li>路径方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">define(&apos;BASE_PATH&apos;,str_replace(&apos;\\&apos;,&apos;/&apos;,realpath(dirname(__FILE__).&apos;/&apos;)).&quot;/&quot;);</div><div class="line">echo BASE_PATH; // 输出结果：E:/wwwroot/</div></pre></td></tr></table></figure><blockquote><p><code>str_replace( &#39;\\&#39; , &#39;/&#39; , realpath(dirname(__FILE__).&#39;/../&#39;))</code>：把向左的“\”转化成向右的“/”。</p></blockquote><ul><li>url方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PHP_SELF=$_SERVER[&apos;PHP_SELF&apos;];</div><div class="line">$url=&apos;http://&apos;.$_SERVER[&apos;HTTP_HOST&apos;].substr($PHP_SELF,0,strrpos($PHP_SELF,&apos;/&apos;)+1);</div><div class="line">echo $url;  // 输出结果：http://localhost/</div></pre></td></tr></table></figure><ul><li><p>PHP取得站点根目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo $_SERVER[&apos;HTTP_HOST&apos;];     //当前请求的 Host: 头部的内容 即域名信信息</div><div class="line">echo $_SERVER[&apos;PHP_SELF&apos;];     //当前正在执行脚本的文件相对网站根目录地址，就算该文件被其他文件引用也可以正确得到地址</div><div class="line">echo $_SERVER[&apos;SCRIPT_NAME&apos;];     //当前正在执行脚本的文件相对网站根目录地址，但当该文件被其他文件引用时，只显示引用文件的相对地址，不显示该被引用脚本的相对地址。</div><div class="line">echo $_SERVER[&apos;DOCUMENT_ROOT&apos;];     //网站相对服务器地址即网站的绝对路径名 #当前运行脚本所在的文档根目录。在服务器配置文件中定义</div><div class="line">echo $_SERVER[&apos;SCRIPT_FILENAME&apos;];     //当前执行脚本的绝对路径名。</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;检查一个变量是否为空&quot;&gt;&lt;a href=&quot;#检查一个变量是否为空&quot; class=&quot;headerlink&quot; title=&quot;检查一个变量是否为空&quot;&gt;&lt;/a&gt;检查一个变量是否为空&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;empty功能&lt;ul&gt;
&lt;li&gt;返回值：&lt;/li&gt;
&lt;li&gt;若变
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>kaggle使用笔记</title>
    <link href="http://yoursite.com/2018/07/06/kaggle%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/06/kaggle使用笔记/</id>
    <published>2018-07-06T03:04:20.000Z</published>
    <updated>2018-07-06T08:26:13.686Z</updated>
    
    <content type="html"><![CDATA[<p>因为参加了DCASE2018比赛的声学场景分类的子任务，这个比赛有个排行榜是用的kaggle来做的，所以在比赛中，用到过kaggle API，下面是关于kaggle的使用笔记。</p><h2 id="kaggle-是什么？"><a href="#kaggle-是什么？" class="headerlink" title="kaggle 是什么？"></a>kaggle 是什么？</h2><p><a href="https://www.kaggle.com/" target="_blank" rel="external">Kaggle</a>是一个数据科学竞赛的平台，很多公司会发布一些接近真实业务的问题，吸引爱好数据科学的人来一起解决。 </p><p>点击导航栏的 competitions 可以看到有很多比赛，其中正式比赛，一般会有奖金或者工作机会，除了正式比赛还有一些为初学者提供的 playground，在这里可以先了解这个比赛，练习能力，再去参加正式比赛。 </p><h2 id="参赛方法"><a href="#参赛方法" class="headerlink" title="参赛方法"></a>参赛方法</h2><p>参赛之前，首先需要一个kaggle的账号，激活之后，找到自己感兴趣的competitions，然后选择“join competitions”即可。</p><h3 id="界面介绍："><a href="#界面介绍：" class="headerlink" title="界面介绍："></a>界面介绍：</h3><ul><li><p><strong>Overview</strong>： 首先在 overview 中仔细阅读问题的描述，这个比赛是让我们预测房价，它会给我们 79 个影响房价的变量，我们可以通过应用 random forest，gradient boosting 等算法，来对房价进行预测。</p></li><li><p><strong>Data</strong>：在这里给我们提供了 train 数据集，用来训练模型；test 数据集，用来将训练好的模型应用到这上面，进行预测，这个结果也是要提交到系统进行评价的；sample_submission 就是我们最后提交的 csv 文件中，里面的列的格式需要和这里一样。</p></li><li><p><strong>Kernels</strong>：可以看到一些参赛者分享的代码。</p></li><li><p><strong>Discussion</strong>：参赛者们可以在这里提问，分享经验。</p></li><li><p><strong>Leaderboard</strong>：就是参赛者的排行榜。</p></li></ul><h3 id="参赛流程"><a href="#参赛流程" class="headerlink" title="参赛流程"></a>参赛流程</h3><p>第一步：在 Data 里面下载三个数据集，最基本的就是上面提到的三个文件，有些比赛会有附加的数据描述文件等。</p><p>第二步：自己在线下分析，建模，调参，把用 test 数据集预测好的结果，按照 sample_submission 的格式输出到 csv 文件中。</p><p>第三步：点击蓝色按钮 ’Submit Predictions’ ，把 csv 文件拖拽进去，然后系统就会加载并检验结果，稍等片刻后就会在 Leaderboard 上显示当前结果所在的排名位置。<br>上传过一次结果之后，就直接加入了这场比赛。</p><blockquote><p>注意：正式比赛中每个团队每天有 5 次的上传机会，然后就要等 24 小时再次传结果，playground 的是 9 次。</p></blockquote><h2 id="kaggle-API的安装及使用"><a href="#kaggle-API的安装及使用" class="headerlink" title="kaggle API的安装及使用"></a>kaggle API的安装及使用</h2><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>首先确保安装了Python和包管理器pip。</p><p>运行以下命令以使用命令行访问Kaggle API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Windows系统，默认的安装目录是“$ PYTHON_HOME / Scripts”</div><div class="line">pip install kaggle</div><div class="line">// Mac / Linux系统</div><div class="line">pip install --user kaggle</div></pre></td></tr></table></figure><h3 id="下载API-credentials"><a href="#下载API-credentials" class="headerlink" title="下载API credentials"></a>下载API credentials</h3><ul><li><p>要使用Kaggle API，需要在<a href="https://www.kaggle.com" target="_blank" rel="external">kaggle官网</a>上注册Kaggle帐户。</p></li><li><p>转到用户个人资料的’Account’标签，然后选择“create API Token”之后会弹出<code>kaggle.json</code>的下载，这是一个包含API credentials的文件。 </p></li><li>将此文件放在<code>〜/ .kaggle / kaggle.json</code>位置（在Windows上的位置<code>C：\ Users \ &lt;Windows-username&gt; \ .kaggle \ kaggle.json</code>）。</li></ul><blockquote><p>第一次安装的时候，再<code>C：\ Users \ &lt;Windows-username&gt; \ .kaggle \ kaggle.json</code>目录下没有<code>.kaggle</code>这个文件夹，后来通过<code>pip uninstall kaggle</code>再重新安装之后，自动出现<code>.kaggle</code>文件夹，随后直接将<code>kaggle.json</code>文件复制到这个文件夹下面了。</p><p>您可以定义一个shell环境变量KAGGLE_CONFIG_DIR来将此位置更改为$ KAGGLE_CONFIG_DIR / kaggle.json（在Windows上它将是％KAGGLE_CONFIG_DIR％\ kaggle.json）。</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>命令行支持命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kaggle competitions &#123;list,files,download,submit,submissions,leaderboard&#125;</div><div class="line">kaggle datasets &#123;list, files, download, create, version, init&#125;</div><div class="line">kaggle config &#123;view, set, unset&#125;</div></pre></td></tr></table></figure><ul><li><p><strong>比赛——API支持Kaggle Competitions的命令</strong>。</p></li><li><p>List competitions</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions list [-h] [-p PAGE] [-s SEARCH] [-v]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -p PAGE, --page PAGE  page number</div><div class="line">  -s SEARCH, --search SEARCH</div><div class="line">                        term(s) to search for</div><div class="line">  -v, --csv             print in CSV format</div><div class="line">                        (if not set print in table format)</div></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle competitions list -s health</div></pre></td></tr></table></figure><ul><li>List competition files</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions files [-h] [-c COMPETITION] [-v] [-q]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -c COMPETITION, --competition COMPETITION</div><div class="line">                        Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        If empty, the default competition will be used (use &quot;kaggle config set competition&quot;)&quot;</div><div class="line">  -v, --csv             Print results in CSV format (if not set print in table format)</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle competitions files -c favorita-grocery-sales-forecasting</div></pre></td></tr></table></figure><ul><li>Download competition files</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions download [-h] [-c COMPETITION] [-f FILE] [-p PATH]</div><div class="line">                                    [-w] [-o] [-q]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -c COMPETITION, --competition COMPETITION</div><div class="line">                        Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        If empty, the default competition will be used (use &quot;kaggle config set competition&quot;)&quot;</div><div class="line">  -f FILE, --file FILE  File name, all files downloaded if not provided</div><div class="line">                        (use &quot;kaggle competitions files -c &lt;competition&gt;&quot; to show options)</div><div class="line">  -p PATH, --path PATH  Folder where file(s) will be downloaded, defaults to  ~/.kaggle</div><div class="line">  -w, --wp              Download files to current working path</div><div class="line">  -o, --force           Skip check whether local version of file is up to date, force file download</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kaggle competitions download -c favorita-grocery-sales-forecasting</div><div class="line">kaggle competitions download -c favorita-grocery-sales-forecasting -f test.csv.7z</div></pre></td></tr></table></figure><ul><li>Submit to a competition</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions submit [-h] [-c COMPETITION] -f FILE -m MESSAGE</div><div class="line">                                  [-q]</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -f FILE, --file FILE  File for upload (full path)</div><div class="line">  -m MESSAGE, --message MESSAGE</div><div class="line">                        Message describing this submission</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -c COMPETITION, --competition COMPETITION</div><div class="line">                        Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        If empty, the default competition will be used (use &quot;kaggle config set competition&quot;)&quot;</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle competitions submit -c favorita-grocery-sales-forecasting -f sample_submission_favorita.csv.7z -m &quot;My submission message&quot;</div></pre></td></tr></table></figure><ul><li>List competition submissions</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions submissions [-h] [-c COMPETITION] [-v] [-q]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -c COMPETITION, --competition COMPETITION</div><div class="line">                        Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        If empty, the default competition will be used (use &quot;kaggle config set competition&quot;)&quot;</div><div class="line">  -v, --csv             Print results in CSV format (if not set print in table format)</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle competitions submissions -c favorita-grocery-sales-forecasting</div></pre></td></tr></table></figure><ul><li>Get competition leaderboard</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">usage: kaggle competitions leaderboard [-h] [-c COMPETITION] [-s] [-d]</div><div class="line">                                       [-p PATH] [-q]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -c COMPETITION, --competition COMPETITION</div><div class="line">                        Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        If empty, the default competition will be used (use &quot;kaggle config set competition&quot;)&quot;</div><div class="line">  -s, --show            Show the top of the leaderboard</div><div class="line">  -d, --download        Download entire leaderboard</div><div class="line">  -p PATH, --path PATH  Folder where file(s) will be downloaded, defaults to ~/.kaggle</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle competitions leaderboard -c favorita-grocery-sales-forecasting -s</div></pre></td></tr></table></figure><p><strong>数据集——API支持以下用于Kaggle数据集的命令。</strong></p><ul><li>List datasets</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets list [-h] [-p PAGE] [-s SEARCH] [-v]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -p PAGE, --page PAGE  Page number for results paging</div><div class="line">  -s SEARCH, --search SEARCH</div><div class="line">                        Term(s) to search for</div><div class="line">  -v, --csv             Print results in CSV format (if not set print in table format)</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle datasets list -s demographics</div></pre></td></tr></table></figure><ul><li>List files for a dataset</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets files [-h] -d DATASET [-v]</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -d DATASET, --dataset DATASET</div><div class="line">                        Dataset URL suffix in format &lt;owner&gt;/&lt;dataset-name&gt; (use &quot;kaggle datasets list&quot; to show options)</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -v, --csv             Print results in CSV format (if not set print in table format)</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle datasets files -d zillow/zecon</div></pre></td></tr></table></figure><ul><li>Download dataset files</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets download [-h] -d DATASET [-f FILE] [-p PATH] [-w] [-o]</div><div class="line">                                [-q]</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -d DATASET, --dataset DATASET</div><div class="line">                        Dataset URL suffix in format &lt;owner&gt;/&lt;dataset-name&gt; (use &quot;kaggle datasets list&quot; to show options)</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -f FILE, --file FILE  File name, all files downloaded if not provided</div><div class="line">                        (use &quot;kaggle datasets files -d &lt;dataset&gt;&quot; to show options)</div><div class="line">  -p PATH, --path PATH  Folder where file(s) will be downloaded, defaults to ~/.kaggle</div><div class="line">  -w, --wp              Download files to current working path</div><div class="line">  -o, --force           Skip check whether local version of file is up to date, force file download</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kaggle datasets download -d zillow/zecon</div><div class="line"></div><div class="line">kaggle datasets download -d zillow/zecon -f State_time_series.csv</div></pre></td></tr></table></figure><ul><li>Initialize metadata file for dataset creation</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets init [-h] -p FOLDER</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -p FOLDER, --path FOLDER</div><div class="line">                        Folder for upload, containing data files and a special metadata.json file (https://github.com/Kaggle/kaggle-api/wiki/Metadata)</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle datasets init -p /path/to/dataset</div></pre></td></tr></table></figure><ul><li>Create a new dataset</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets create [-h] -p FOLDER [-u] [-q]</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -p FOLDER, --path FOLDER</div><div class="line">                        Folder for upload, containing data files and a special metadata.json file (https://github.com/Kaggle/kaggle-api/wiki/Metadata)</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -u, --public          Create the Dataset publicly (default is private)</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div><div class="line">  -t, --keep-tabular    Do not convert tabular files to CSV (default is to convert)</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle datasets create -p /path/to/dataset</div></pre></td></tr></table></figure><ul><li>Create a new dataset version</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">usage: kaggle datasets version [-h] -m VERSION_NOTES -p FOLDER [-q]</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -m VERSION_NOTES, --message VERSION_NOTES</div><div class="line">                        Message describing the new version</div><div class="line">  -p FOLDER, --path FOLDER</div><div class="line">                        Folder for upload, containing data files and a special metadata.json file (https://github.com/Kaggle/kaggle-api/wiki/Metadata)</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -q, --quiet           Suppress printing information about download progress</div><div class="line">  -t, --keep-tabular    Do not convert tabular files to CSV (default is to convert)</div><div class="line">  -d, --delete-old-versions</div><div class="line">                        Delete old versions of this dataset</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle datasets version -p /path/to/dataset -m &quot;Updated data&quot;</div></pre></td></tr></table></figure><p><strong>配置</strong></p><ul><li>View current config values</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">usage: kaggle config path [-h] [-p PATH]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this help message and exit</div><div class="line">  -p PATH, --path PATH  folder where file(s) will be downloaded, defaults to ~/.kaggle</div><div class="line">Example:</div><div class="line"></div><div class="line">kaggle config path -p C:\</div><div class="line"></div><div class="line">View current config values</div><div class="line">usage: kaggle config view [-h]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help  show this help message and exit</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle config view</div></pre></td></tr></table></figure><ul><li>Set a configuration value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">usage: kaggle config set [-h] -n NAME -v VALUE</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -n NAME, --name NAME  Name of the configuration parameter</div><div class="line">                        (one of competition, path, proxy)</div><div class="line">  -v VALUE, --value VALUE</div><div class="line">                        Value of the configuration parameter, valid values depending on name</div><div class="line">                        - competition: Competition URL suffix (use &quot;kaggle competitions list&quot; to show options)</div><div class="line">                        - path: Folder where file(s) will be downloaded, defaults to ~/.kaggle</div><div class="line">                        - proxy: Proxy for HTTP requests</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle config set -n competition -v titanic</div></pre></td></tr></table></figure><ul><li>Clear a configuration value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usage: kaggle config unset [-h] -n NAME</div><div class="line"></div><div class="line">required arguments:</div><div class="line">  -n NAME, --name NAME  Name of the configuration parameter</div><div class="line">                        (one of competition, path, proxy)</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kaggle config unset -n competition</div></pre></td></tr></table></figure><p>注意：目前最大的限制是此时不以任何方式支持内核。 我们打算在不久的将来实施支持，尽管没有ETA。 此外，目前无法使用大型数据集（&gt; = 2GB）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.kaggle.com/" target="_blank" rel="external">kaggle官网</a></li><li><a href="https://github.com/Kaggle/kaggle-api" target="_blank" rel="external">kaggle API</a></li><li><a href="https://blog.csdn.net/qunnie_yi/article/details/80129508" target="_blank" rel="external">从0到1走进 Kaggle</a></li><li><a href="https://blog.csdn.net/aliceyangxi1987/article/details/71079448" target="_blank" rel="external">一个框架解决几乎所有机器学习问题</a></li><li><a href="https://www.jianshu.com/p/f648de991d51" target="_blank" rel="external">Kaggle比赛：从何着手？</a></li><li><a href="https://www.aliyun.com/jiaocheng/435330.html?spm=5176.100033.2.8.f0tCsX" target="_blank" rel="external">kaggle入门（python数据处理）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为参加了DCASE2018比赛的声学场景分类的子任务，这个比赛有个排行榜是用的kaggle来做的，所以在比赛中，用到过kaggle API，下面是关于kaggle的使用笔记。&lt;/p&gt;
&lt;h2 id=&quot;kaggle-是什么？&quot;&gt;&lt;a href=&quot;#kaggle-是什么？&quot; 
      
    
    </summary>
    
      <category term="DCASE" scheme="http://yoursite.com/categories/DCASE/"/>
    
    
      <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
  </entry>
  
</feed>
